# COMMAND 4 OF 4: API ENDPOINTS & ADMIN DASHBOARD

Copy and paste this into Replit Agent:

-----

```
BUILD BJJ OS AI INTELLIGENCE - PART 4: API ENDPOINTS & ADMIN DASHBOARD

CRITICAL SAFETY RULES:
âŒ DO NOT modify existing SMS delivery endpoints
âŒ DO NOT touch existing /send-daily-technique route
âœ… Create NEW API routes under /api/ai/*
âœ… Create NEW admin dashboard page
âœ… All new endpoints are additive only

This is the FINAL command. After this, the complete AI intelligence system will be operational.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 1: CREATE AI API ROUTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Create new file: /server/routes/ai_routes.js

const express = require('express');
const router = express.Router();
const ai = require('../ai_intelligence');

// =============================================================================
// VIDEO ANALYSIS ENDPOINTS
// =============================================================================

// Analyze a new video and add to knowledge base
router.post('/analyze-video', async (req, res) => {
  try {
    const { videoUrl, videoTitle, instructor } = req.body;
    
    if (!videoUrl || !videoTitle || !instructor) {
      return res.status(400).json({ 
        error: 'Missing required fields: videoUrl, videoTitle, instructor' 
      });
    }
    
    console.log(`ğŸ“¹ Analyzing video: ${videoTitle}`);
    const videoId = await ai.analyzeAndStoreVideo(videoUrl, videoTitle, instructor);
    
    res.json({
      success: true,
      videoId: videoId,
      message: 'Video analyzed and stored successfully'
    });
    
  } catch (error) {
    console.error('Error analyzing video:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get video knowledge
router.get('/video/:videoId', async (req, res) => {
  try {
    const { videoId } = req.params;
    
    const video = await ai.pool.query(`
      SELECT * FROM ai_video_knowledge WHERE id = $1
    `, [videoId]);
    
    if (video.rows.length === 0) {
      return res.status(404).json({ error: 'Video not found' });
    }
    
    res.json(video.rows[0]);
    
  } catch (error) {
    console.error('Error fetching video:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get all analyzed videos
router.get('/videos', async (req, res) => {
  try {
    const videos = await ai.pool.query(`
      SELECT 
        id, video_url, technique_name, instructor_name,
        position_category, technique_type, difficulty_score,
        avg_user_rating, total_ratings, times_sent_to_users,
        created_at
      FROM ai_video_knowledge
      ORDER BY created_at DESC
      LIMIT 100
    `);
    
    res.json({
      count: videos.rows.length,
      videos: videos.rows
    });
    
  } catch (error) {
    console.error('Error fetching videos:', error);
    res.status(500).json({ error: error.message });
  }
});

// =============================================================================
// USER FEEDBACK ENDPOINTS
// =============================================================================

// Record user feedback
router.post('/feedback', async (req, res) => {
  try {
    const { userId, videoId, signalType, signalValue } = req.body;
    
    if (!userId || !signalType || !signalValue) {
      return res.status(400).json({ 
        error: 'Missing required fields: userId, signalType, signalValue' 
      });
    }
    
    await ai.processUserFeedback(userId, videoId, signalType, signalValue);
    
    res.json({
      success: true,
      message: 'Feedback processed successfully'
    });
    
  } catch (error) {
    console.error('Error processing feedback:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get user context
router.get('/user/:userId/context', async (req, res) => {
  try {
    const { userId } = req.params;
    
    const context = await ai.loadFullUserContext(parseInt(userId));
    
    if (!context) {
      return res.status(404).json({ error: 'User context not found' });
    }
    
    res.json(context);
    
  } catch (error) {
    console.error('Error loading context:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update user profile
router.post('/user/:userId/profile', async (req, res) => {
  try {
    const { userId } = req.params;
    const updates = req.body;
    
    // Build dynamic update query
    const fields = [];
    const values = [userId];
    let paramCount = 2;
    
    for (const [key, value] of Object.entries(updates)) {
      fields.push(`${key} = $${paramCount}`);
      values.push(value);
      paramCount++;
    }
    
    if (fields.length === 0) {
      return res.status(400).json({ error: 'No fields to update' });
    }
    
    const query = `
      INSERT INTO ai_user_context (user_id, ${Object.keys(updates).join(', ')})
      VALUES ($1, ${Object.keys(updates).map((_, i) => `$${i + 2}`).join(', ')})
      ON CONFLICT (user_id) DO UPDATE SET
        ${fields.join(', ')},
        updated_at = NOW()
      RETURNING *
    `;
    
    const result = await ai.pool.query(query, values);
    
    res.json({
      success: true,
      profile: result.rows[0]
    });
    
  } catch (error) {
    console.error('Error updating profile:', error);
    res.status(500).json({ error: error.message });
  }
});

// =============================================================================
// ENHANCED SCORING ENDPOINTS
// =============================================================================

// Get enhanced technique recommendation
router.post('/recommend/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    
    console.log(`ğŸ¯ Getting recommendation for user ${userId}`);
    const recommendation = await ai.enhancedTechniqueScoring(parseInt(userId));
    
    if (!recommendation) {
      return res.json({
        success: false,
        message: 'Enhanced scoring not enabled or no videos available',
        fallbackToOld: true
      });
    }
    
    res.json({
      success: true,
      recommendation: recommendation
    });
    
  } catch (error) {
    console.error('Error getting recommendation:', error);
    res.status(500).json({ error: error.message });
  }
});

// =============================================================================
// FEATURE FLAG ENDPOINTS
// =============================================================================

// Get all feature flags
router.get('/features', async (req, res) => {
  try {
    const flags = await ai.pool.query(`
      SELECT * FROM ai_feature_flags ORDER BY feature_name
    `);
    
    res.json({
      count: flags.rows.length,
      features: flags.rows
    });
    
  } catch (error) {
    console.error('Error fetching features:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update feature flag
router.post('/features/:featureName', async (req, res) => {
  try {
    const { featureName } = req.params;
    const { isEnabled, rolloutPercentage } = req.body;
    
    await ai.setFeatureRollout(
      featureName, 
      rolloutPercentage !== undefined ? rolloutPercentage : 0,
      isEnabled !== undefined ? isEnabled : true
    );
    
    res.json({
      success: true,
      message: `Feature ${featureName} updated`
    });
    
  } catch (error) {
    console.error('Error updating feature:', error);
    res.status(500).json({ error: error.message });
  }
});

// Enable feature for specific user
router.post('/features/:featureName/user/:userId', async (req, res) => {
  try {
    const { featureName, userId } = req.params;
    
    await ai.enableFeatureForUser(featureName, parseInt(userId));
    
    res.json({
      success: true,
      message: `Feature ${featureName} enabled for user ${userId}`
    });
    
  } catch (error) {
    console.error('Error enabling feature:', error);
    res.status(500).json({ error: error.message });
  }
});

// =============================================================================
// ANALYTICS ENDPOINTS
// =============================================================================

// Get AI intelligence stats
router.get('/stats', async (req, res) => {
  try {
    const stats = await ai.pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM ai_video_knowledge) as total_videos,
        (SELECT COUNT(*) FROM ai_user_feedback_signals) as total_signals,
        (SELECT COUNT(*) FROM ai_user_context) as users_with_context,
        (SELECT COUNT(*) FROM ai_technique_relationships) as relationships_mapped,
        (SELECT COUNT(*) FROM ai_problem_solution_map) as problems_mapped,
        (SELECT AVG(confidence_score) FROM ai_confidence_tracking) as avg_confidence
    `);
    
    res.json({
      stats: stats.rows[0],
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error fetching stats:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get recent reasoning traces
router.get('/reasoning', async (req, res) => {
  try {
    const { limit = 20 } = req.query;
    
    const traces = await ai.pool.query(`
      SELECT 
        decision_id, decision_type, user_id,
        final_decision, confidence, user_friendly_explanation,
        created_at
      FROM ai_reasoning_traces
      ORDER BY created_at DESC
      LIMIT $1
    `, [limit]);
    
    res.json({
      count: traces.rows.length,
      traces: traces.rows
    });
    
  } catch (error) {
    console.error('Error fetching reasoning:', error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 2: INTEGRATE AI ROUTES INTO MAIN SERVER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Add to your main server file (server.js or index.js):

// Add this line with your other requires at the top
const aiRoutes = require('./routes/ai_routes');

// Add this line with your other route registrations
app.use('/api/ai', aiRoutes);

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 3: CREATE ADMIN DASHBOARD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Create new file: /public/admin-ai.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BJJ OS - AI Intelligence Dashboard</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #0a0a0a;
      color: #fff;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .subtitle {
      color: #888;
      margin-bottom: 40px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 40px;
    }
    
    .stat-card {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 24px;
    }
    
    .stat-label {
      color: #888;
      font-size: 0.9rem;
      margin-bottom: 8px;
    }
    
    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: #667eea;
    }
    
    .section {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 30px;
    }
    
    .section h2 {
      font-size: 1.5rem;
      margin-bottom: 20px;
      color: #fff;
    }
    
    .feature-flag {
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .feature-info h3 {
      font-size: 1.1rem;
      margin-bottom: 5px;
    }
    
    .feature-info p {
      color: #888;
      font-size: 0.9rem;
    }
    
    .feature-controls {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .toggle {
      position: relative;
      width: 60px;
      height: 30px;
    }
    
    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #333;
      transition: 0.3s;
      border-radius: 30px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: #667eea;
    }
    
    input:checked + .slider:before {
      transform: translateX(30px);
    }
    
    .percentage-input {
      width: 80px;
      padding: 8px 12px;
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 6px;
      color: #fff;
      font-size: 0.9rem;
    }
    
    .btn {
      padding: 10px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: 0.2s;
    }
    
    .btn:hover {
      background: #5568d3;
    }
    
    .btn-secondary {
      background: #333;
    }
    
    .btn-secondary:hover {
      background: #444;
    }
    
    .video-form {
      display: grid;
      gap: 15px;
      margin-top: 20px;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .form-group label {
      color: #888;
      font-size: 0.9rem;
    }
    
    .form-group input {
      padding: 12px;
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 6px;
      color: #fff;
      font-size: 1rem;
    }
    
    .success-message {
      background: #1a4d1a;
      border: 1px solid #2d7a2d;
      color: #4ade80;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .error-message {
      background: #4d1a1a;
      border: 1px solid #7a2d2d;
      color: #f87171;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }
    
    .video-list {
      display: grid;
      gap: 15px;
      max-height: 500px;
      overflow-y: auto;
    }
    
    .video-item {
      background: #0f0f0f;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 15px;
    }
    
    .video-item h4 {
      margin-bottom: 8px;
      color: #667eea;
    }
    
    .video-meta {
      display: flex;
      gap: 20px;
      color: #888;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ§  AI Intelligence Dashboard</h1>
    <p class="subtitle">Monitor and control the BJJ OS AI system</p>
    
    <div id="message"></div>
    
    <!-- Stats Section -->
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Videos Analyzed</div>
        <div class="stat-value" id="stat-videos">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">User Signals</div>
        <div class="stat-value" id="stat-signals">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Users with Context</div>
        <div class="stat-value" id="stat-users">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Relationships Mapped</div>
        <div class="stat-value" id="stat-relationships">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Problems Mapped</div>
        <div class="stat-value" id="stat-problems">-</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Avg Confidence</div>
        <div class="stat-value" id="stat-confidence">-</div>
      </div>
    </div>
    
    <!-- Feature Flags Section -->
    <div class="section">
      <h2>ğŸš© Feature Flags</h2>
      <div id="feature-flags"></div>
    </div>
    
    <!-- Analyze Video Section -->
    <div class="section">
      <h2>ğŸ“¹ Analyze New Video</h2>
      <form class="video-form" id="analyze-form">
        <div class="form-group">
          <label>Video URL</label>
          <input type="url" id="video-url" placeholder="https://youtube.com/watch?v=..." required>
        </div>
        <div class="form-group">
          <label>Video Title</label>
          <input type="text" id="video-title" placeholder="Triangle Choke from Closed Guard" required>
        </div>
        <div class="form-group">
          <label>Instructor Name</label>
          <input type="text" id="instructor" placeholder="John Danaher" required>
        </div>
        <button type="submit" class="btn">Analyze Video</button>
      </form>
    </div>
    
    <!-- Recent Videos Section -->
    <div class="section">
      <h2>ğŸ“š Recently Analyzed Videos</h2>
      <div id="video-list" class="video-list"></div>
    </div>
  </div>
  
  <script>
    // Load initial data
    async function loadDashboard() {
      await loadStats();
      await loadFeatureFlags();
      await loadVideos();
    }
    
    async function loadStats() {
      try {
        const response = await fetch('/api/ai/stats');
        const data = await response.json();
        
        document.getElementById('stat-videos').textContent = data.stats.total_videos || 0;
        document.getElementById('stat-signals').textContent = data.stats.total_signals || 0;
        document.getElementById('stat-users').textContent = data.stats.users_with_context || 0;
        document.getElementById('stat-relationships').textContent = data.stats.relationships_mapped || 0;
        document.getElementById('stat-problems').textContent = data.stats.problems_mapped || 0;
        
        const confidence = data.stats.avg_confidence 
          ? (parseFloat(data.stats.avg_confidence) * 100).toFixed(0) + '%'
          : 'N/A';
        document.getElementById('stat-confidence').textContent = confidence;
        
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    }
    
    async function loadFeatureFlags() {
      try {
        const response = await fetch('/api/ai/features');
        const data = await response.json();
        
        const container = document.getElementById('feature-flags');
        container.innerHTML = data.features.map(feature => `
          <div class="feature-flag">
            <div class="feature-info">
              <h3>${feature.feature_name}</h3>
              <p>${feature.feature_description}</p>
            </div>
            <div class="feature-controls">
              <label class="toggle">
                <input type="checkbox" 
                  ${feature.is_enabled ? 'checked' : ''} 
                  onchange="toggleFeature('${feature.feature_name}', this.checked)">
                <span class="slider"></span>
              </label>
              <input type="number" 
                class="percentage-input" 
                value="${feature.rollout_percentage}" 
                min="0" 
                max="100"
                onchange="updateRollout('${feature.feature_name}', this.value)">
              <span>%</span>
            </div>
          </div>
        `).join('');
        
      } catch (error) {
        console.error('Error loading features:', error);
      }
    }
    
    async function toggleFeature(featureName, enabled) {
      try {
        const response = await fetch(`/api/ai/features/${featureName}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ isEnabled: enabled })
        });
        
        if (response.ok) {
          showMessage(`Feature ${featureName} ${enabled ? 'enabled' : 'disabled'}`, 'success');
        }
      } catch (error) {
        showMessage('Error updating feature: ' + error.message, 'error');
      }
    }
    
    async function updateRollout(featureName, percentage) {
      try {
        const response = await fetch(`/api/ai/features/${featureName}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ rolloutPercentage: parseInt(percentage) })
        });
        
        if (response.ok) {
          showMessage(`Rollout updated to ${percentage}%`, 'success');
        }
      } catch (error) {
        showMessage('Error updating rollout: ' + error.message, 'error');
      }
    }
    
    async function loadVideos() {
      try {
        const response = await fetch('/api/ai/videos');
        const data = await response.json();
        
        const container = document.getElementById('video-list');
        
        if (data.videos.length === 0) {
          container.innerHTML = '<p style="color: #888; text-align: center;">No videos analyzed yet. Add one above!</p>';
          return;
        }
        
        container.innerHTML = data.videos.map(video => `
          <div class="video-item">
            <h4>${video.technique_name}</h4>
            <div class="video-meta">
              <span>ğŸ‘¤ ${video.instructor_name || 'Unknown'}</span>
              <span>ğŸ“ ${video.position_category || 'N/A'}</span>
              <span>â­ ${video.avg_user_rating ? video.avg_user_rating.toFixed(1) : 'N/A'}</span>
              <span>ğŸ“¤ Sent ${video.times_sent_to_users || 0} times</span>
              <span>ğŸ¯ Difficulty ${video.difficulty_score || 'N/A'}/10</span>
            </div>
          </div>
        `).join('');
        
      } catch (error) {
        console.error('Error loading videos:', error);
      }
    }
    
    // Analyze video form
    document.getElementById('analyze-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const videoUrl = document.getElementById('video-url').value;
      const videoTitle = document.getElementById('video-title').value;
      const instructor = document.getElementById('instructor').value;
      
      showMessage('Analyzing video... This may take 10-30 seconds.', 'success');
      
      try {
        const response = await fetch('/api/ai/analyze-video', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoUrl, videoTitle, instructor })
        });
        
        const data = await response.json();
        
        if (response.ok) {
          showMessage('âœ… Video analyzed successfully!', 'success');
          document.getElementById('analyze-form').reset();
          await loadStats();
          await loadVideos();
        } else {
          showMessage('Error: ' + data.error, 'error');
        }
        
      } catch (error) {
        showMessage('Error analyzing video: ' + error.message, 'error');
      }
    });
    
    function showMessage(text, type) {
      const messageDiv = document.getElementById('message');
      messageDiv.className = type === 'success' ? 'success-message' : 'error-message';
      messageDiv.textContent = text;
      messageDiv.style.display = 'block';
      
      setTimeout(() => {
        messageDiv.style.display = 'none';
      }, 5000);
    }
    
    // Load dashboard on page load
    loadDashboard();
    
    // Refresh stats every 30 seconds
    setInterval(loadStats, 30000);
  </script>
</body>
</html>

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 4: INTEGRATION WITH EXISTING SMS SYSTEM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Create new file: /server/enhanced_daily_sender.js

This integrates enhanced scoring into your daily SMS routine WITHOUT breaking existing code.

const ai = require('./ai_intelligence');

async function getEnhancedDailyTechnique(userId) {
  /*
  This function can be called from your existing daily SMS sender.
  If enhanced scoring is enabled, it uses the AI.
  If not, it returns null and you use your old method.
  
  SAFE INTEGRATION - Zero risk to existing system.
  */
  
  try {
    // Check if enhanced scoring is enabled for this user
    const isEnabled = await ai.isFeatureEnabled('enhanced_scoring', userId);
    
    if (!isEnabled) {
      console.log(`User ${userId}: Enhanced scoring not enabled, using old method`);
      return null; // Fall back to old technique selection
    }
    
    console.log(`User ${userId}: Using enhanced scoring`);
    const recommendation = await ai.enhancedTechniqueScoring(userId);
    
    if (!recommendation) {
      console.log(`User ${userId}: Enhanced scoring returned null, using old method`);
      return null;
    }
    
    // Return in format compatible with existing SMS system
    return {
      videoUrl: recommendation.videoUrl,
      techniqueName: recommendation.techniqueName,
      instructor: recommendation.instructor,
      score: recommendation.score,
      aiGenerated: true, // Flag to indicate this came from AI
      decisionId: recommendation.decisionId
    };
    
  } catch (error) {
    console.error(`Error getting enhanced technique for user ${userId}:`, error);
    return null; // Safely fall back to old method on any error
  }
}

module.exports = {
  getEnhancedDailyTechnique
};

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 5: EXAMPLE INTEGRATION INTO YOUR EXISTING CODE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Here's how to integrate enhanced scoring into your existing daily SMS sender:

// In your existing daily SMS sending code, add this at the top:
const { getEnhancedDailyTechnique } = require('./enhanced_daily_sender');

// Then in your technique selection logic, do this:

async function selectTechniqueForUser(userId) {
  // TRY enhanced scoring first
  const enhancedTechnique = await getEnhancedDailyTechnique(userId);
  
  if (enhancedTechnique) {
    console.log(`âœ… Using AI-selected technique for user ${userId}`);
    return enhancedTechnique;
  }
  
  // FALL BACK to your existing technique selection
  console.log(`âš ï¸ Using old technique selection for user ${userId}`);
  // ... your existing code here ...
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 6: QUICK START GUIDE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

After Replit Agent completes this command:

1. ACCESS ADMIN DASHBOARD:
   Visit: https://your-replit-url.repl.co/admin-ai.html

2. ANALYZE YOUR FIRST VIDEO:
   - Enter a YouTube URL, title, and instructor name
   - Click "Analyze Video"
   - Wait 10-30 seconds for Claude to analyze it
   - Video knowledge will be stored in database

3. ENABLE ENHANCED SCORING FOR YOURSELF:
   Run in Replit shell:
   node -e "const ai = require('./server/ai_intelligence'); ai.enableFeatureForUser('enhanced_scoring', 1).then(() => process.exit())"
   
   (Replace 1 with your actual user ID)

4. TEST ENHANCED SCORING:
   curl https://your-replit-url.repl.co/api/ai/recommend/1
   
   (Replace 1 with your user ID)

5. GRADUALLY ROLL OUT:
   In admin dashboard:
   - Set "enhanced_scoring" to 10% to test with 10% of users
   - Monitor for 1 week
   - Increase to 25%, then 50%, then 100%

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERIFICATION CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

After implementation, verify:

â–¡ Admin dashboard loads at /admin-ai.html
â–¡ All API endpoints work at /api/ai/*
â–¡ Can analyze a video successfully
â–¡ Stats display correctly
â–¡ Feature flags can be toggled
â–¡ Enhanced scoring returns null when disabled (safe fallback)
â–¡ Enhanced scoring returns recommendation when enabled
â–¡ Existing SMS system still works unchanged

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FINAL NOTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ‰ CONGRATULATIONS! 

You now have a complete 29-feature AI intelligence system that:

âœ… Learns from every video analyzed
âœ… Learns from every user interaction
âœ… Provides personalized recommendations
âœ… Builds knowledge over time
âœ… Is 100% safe (feature flag controlled)
âœ… Falls back gracefully if disabled
âœ… Has admin dashboard for control
âœ… Has full API for extensibility

This system will get smarter every day as:
- More videos are analyzed
- More users provide feedback
- More data accumulates
- Patterns emerge

The moat grows deeper automatically. 

No competitor can replicate this without years of data.

ğŸš€ You're ready to launch the most intelligent BJJ coaching AI in the world.
```

-----

**Send this final command to Replit Agent. Once complete, youâ€™ll have the full AI intelligence system operational!**

After Replit confirms completion, Iâ€™ll give you:

1. Testing instructions
1. How to enable enhanced scoring for your account
1. Tips for analyzing your first videos
1. Rollout strategy

**Let me know when Command 4 is complete!** ğŸ‰â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹