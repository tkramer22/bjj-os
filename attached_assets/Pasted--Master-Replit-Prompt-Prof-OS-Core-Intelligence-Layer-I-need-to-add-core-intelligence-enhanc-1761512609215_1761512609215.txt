# Master Replit Prompt: Prof. OS Core Intelligence Layer

```
I need to add core intelligence enhancements to my existing Prof. OS system in BJJ OS. This is ADDITIVE - do not modify existing functionality. These enhancements will make Prof. OS feel magical and personal.

## CRITICAL: WHAT ALREADY EXISTS (DO NOT MODIFY)

EXISTING TABLES (keep as-is):
- users
- training_sessions
- ai_video_knowledge
- (any other existing tables)

EXISTING FEATURES (preserve completely):
- Prof. OS personality and coaching tone
- Video recommendation system (1-3 videos with context)
- Journey-focused language ("YOUR game", "YOUR journey")
- Belt-specific coaching
- Age/body type awareness
- Injury awareness
- Gi/No-gi preference tracking
- User feedback system (üëç üëé on videos)

DO NOT modify existing Prof. OS system prompts or personality.
DO NOT change existing database tables.
DO NOT alter video recommendation logic.

---

## OVERVIEW: 4 CORE ENHANCEMENTS

We're adding:
1. **Tiered Memory System** - Remember user's journey naturally
2. **Silent Effectiveness Tracking** - Learn what coaching works for each user
3. **Performance Optimization** - Fast, smooth responses
4. **Gentle Engagement Nudges** - Help users discover Prof. OS's full power

Plus: **Multi-model routing** (Claude + GPT-4o)

---

## PART 1: NEW DATABASE TABLES

Add these tables alongside existing ones:

```sql
-- ===== MULTI-MODEL TRACKING =====

CREATE TABLE ai_model_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  
  model_name VARCHAR(50),              -- 'claude-sonnet-4.5', 'gpt-4o', 'gpt-4o-mini'
  task_type VARCHAR(50),               -- 'coaching', 'extraction', 'embedding'
  
  tokens_input INT,
  tokens_output INT,
  cost_usd DECIMAL(10, 6),
  response_time_ms INT,
  
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_model_usage_user ON ai_model_usage(user_id);
CREATE INDEX idx_model_usage_date ON ai_model_usage(created_at DESC);

-- ===== TIERED MEMORY SYSTEM =====

-- User's journey memories (breakthrough moments, struggles, milestones)
CREATE TABLE user_memory_markers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  
  memory_type VARCHAR(50),                -- "breakthrough", "struggle_pattern", "milestone", "injury_concern"
  summary TEXT NOT NULL,                  -- Human-readable memory
  significance_score INT CHECK (significance_score BETWEEN 1 AND 10),
  
  full_context JSONB,                     -- Supporting details
  related_session_ids UUID[],             -- Sessions that created this memory
  
  -- Tiered memory management
  memory_tier VARCHAR(20) DEFAULT 'working',  -- "working" (30 days), "long_term" (forever)
  
  occurred_at TIMESTAMP NOT NULL,
  
  -- Reference tracking (for memory promotion)
  reference_count INT DEFAULT 0,
  last_referenced_at TIMESTAMP,
  
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_memory_user_tier ON user_memory_markers(user_id, memory_tier);
CREATE INDEX idx_memory_occurred ON user_memory_markers(occurred_at DESC);
CREATE INDEX idx_memory_significance ON user_memory_markers(user_id, significance_score DESC);

-- ===== COACHING EFFECTIVENESS TRACKING (SILENT) =====

-- Track which coaching advice actually helps users
CREATE TABLE coaching_outcomes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  
  -- What advice was given
  advice_given TEXT NOT NULL,
  advice_type VARCHAR(50),                -- "technique_suggestion", "pattern_alert", "encouragement", "correction"
  
  given_at TIMESTAMP DEFAULT NOW(),
  
  -- User context when advice given
  user_belt_level VARCHAR(20),
  user_total_sessions INT,
  
  -- Effectiveness tracking (measured from next 3 sessions)
  user_followed_advice BOOLEAN,
  advice_was_effective BOOLEAN,
  measured_at TIMESTAMP,
  
  -- Learning features
  user_cognitive_style VARCHAR(50),       -- If known: "data_driven", "supportive", "visual"
  response_length VARCHAR(20),            -- "brief", "detailed"
  
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_coaching_outcomes_user ON coaching_outcomes(user_id);
CREATE INDEX idx_coaching_outcomes_effective ON coaching_outcomes(advice_was_effective);

-- ===== GENTLE ENGAGEMENT SYSTEM =====

-- Subtle nudges to help users discover Prof. OS's power
CREATE TABLE engagement_nudges (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  
  nudge_type VARCHAR(50),                 -- "discover_session_logging", "discover_pattern_detection", "pre_training_focus"
  
  trigger_reason TEXT,                    -- Why this nudge was created
  content TEXT NOT NULL,                  -- What to show user
  
  optimal_delivery_time TIMESTAMP,        -- When to show this
  priority VARCHAR(20) DEFAULT 'low',     -- "low", "medium", "high"
  
  -- Delivery tracking
  delivered_at TIMESTAMP,
  user_action VARCHAR(50),                -- "acted_on", "dismissed", "ignored"
  
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_nudges_user_pending ON engagement_nudges(user_id, delivered_at) WHERE delivered_at IS NULL;
CREATE INDEX idx_nudges_delivery_time ON engagement_nudges(optimal_delivery_time) WHERE delivered_at IS NULL;

-- ===== USER ENGAGEMENT PROFILE =====

-- Track how user engages to help them discover features
CREATE TABLE user_engagement_profile (
  user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  
  -- Discovery journey
  has_logged_session BOOLEAN DEFAULT false,
  first_session_logged_at TIMESTAMP,
  total_sessions_logged INT DEFAULT 0,
  
  has_asked_for_advice BOOLEAN DEFAULT false,
  first_advice_asked_at TIMESTAMP,
  
  has_received_pattern_insight BOOLEAN DEFAULT false,
  first_pattern_insight_at TIMESTAMP,
  
  -- Usage patterns
  primary_use_case VARCHAR(50),           -- "video_search", "session_logging", "coaching", "mixed"
  last_video_request_at TIMESTAMP,
  last_session_log_at TIMESTAMP,
  
  -- Engagement stage
  engagement_stage VARCHAR(50) DEFAULT 'discovery',  -- "discovery", "video_user", "light_logger", "power_user"
  stage_updated_at TIMESTAMP DEFAULT NOW(),
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- ===== PERFORMANCE MONITORING =====

CREATE TABLE performance_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  endpoint VARCHAR(100),
  user_id UUID,
  
  duration_ms INT,
  cache_hit BOOLEAN DEFAULT false,
  
  db_queries_count INT DEFAULT 0,
  ai_calls_count INT DEFAULT 0,
  
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_perf_endpoint_date ON performance_metrics(endpoint, created_at DESC);
```

-----

## PART 2: MULTI-MODEL AI ROUTER

Create `services/aiRouter.js`:

```javascript
import Anthropic from '@anthropic-ai/sdk';
import OpenAI from 'openai';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

export class AIRouter {
  
  async handleMessage(userMessage, context, taskType = 'coaching') {
    const startTime = Date.now();
    const route = this.determineRoute(taskType);
    
    let result;
    
    try {
      if (route.model === 'claude') {
        result = await this.callClaude(userMessage, context, route.config);
      } else if (route.model === 'gpt') {
        result = await this.callGPT(userMessage, context, route.config);
      }
      
      // Track usage
      await this.trackUsage({
        userId: context.userId,
        modelName: result.model,
        taskType,
        tokensInput: result.tokens.input,
        tokensOutput: result.tokens.output,
        cost: this.calculateCost(result.model, result.tokens),
        responseTimeMs: Date.now() - startTime
      });
      
      return result.content;
      
    } catch (error) {
      console.error('AI Router error:', error);
      throw error;
    }
  }
  
  determineRoute(taskType) {
    // Use GPT for embeddings (cheaper, excellent quality)
    if (taskType === 'embedding') {
      return {
        model: 'gpt',
        config: { model: 'text-embedding-3-small' }
      };
    }
    
    // Use GPT for structured extraction (JSON mode)
    if (taskType === 'extraction' || taskType === 'structured') {
      return {
        model: 'gpt',
        config: {
          model: 'gpt-4o-mini',
          response_format: { type: 'json_object' }
        }
      };
    }
    
    // Default: Claude for main coaching (best quality)
    return {
      model: 'claude',
      config: { model: 'claude-sonnet-4-5-20250929' }
    };
  }
  
  async callClaude(message, context, config) {
    const systemPrompt = this.buildSystemPrompt(context);
    
    const response = await anthropic.messages.create({
      model: config.model,
      max_tokens: 2000,
      system: systemPrompt,
      messages: this.buildMessages(message, context)
    });
    
    return {
      content: response.content[0].text,
      model: 'claude',
      tokens: {
        input: response.usage.input_tokens,
        output: response.usage.output_tokens
      }
    };
  }
  
  async callGPT(message, context, config) {
    const messages = this.buildMessages(message, context);
    
    const response = await openai.chat.completions.create({
      model: config.model,
      messages,
      ...(config.response_format && { response_format: config.response_format })
    });
    
    return {
      content: response.choices[0].message.content,
      model: config.model,
      tokens: {
        input: response.usage.prompt_tokens,
        output: response.usage.completion_tokens
      }
    };
  }
  
  buildSystemPrompt(context) {
    // Use existing Prof. OS system prompt as base
    let prompt = process.env.PROF_OS_BASE_PROMPT;
    
    // Add memory context if available
    if (context.relevantMemories?.length > 0) {
      const memoriesText = context.relevantMemories
        .map(m => `- ${m.summary} (${this.formatDate(m.occurred_at)})`)
        .join('\n');
      
      prompt += `\n\nRELEVANT MEMORIES ABOUT THIS USER:\n${memoriesText}\n\nReference these memories naturally when relevant. Don't force them into every response.`;
    }
    
    // Add adaptive coaching style if learned
    if (context.coachingStyle) {
      prompt += `\n\nADAPTIVE COACHING FOR THIS USER:\n`;
      
      if (context.coachingStyle.prefers_brief) {
        prompt += `- Keep responses concise (2-3 paragraphs)\n`;
      }
      
      if (context.coachingStyle.responds_to_data) {
        prompt += `- Include specific success rates and metrics\n`;
      } else if (context.coachingStyle.responds_to_encouragement) {
        prompt += `- Lead with encouragement and support\n`;
      }
    }
    
    return prompt;
  }
  
  buildMessages(message, context) {
    const messages = [];
    
    // Add recent conversation history if available
    if (context.conversationHistory?.length > 0) {
      messages.push(...context.conversationHistory.slice(-10)); // Last 10 messages
    }
    
    // Add current message
    messages.push({
      role: 'user',
      content: message
    });
    
    return messages;
  }
  
  calculateCost(model, tokens) {
    const pricing = {
      'claude-sonnet-4-5-20250929': { input: 0.003, output: 0.015 },
      'gpt-4o': { input: 0.0025, output: 0.01 },
      'gpt-4o-mini': { input: 0.00015, output: 0.0006 },
      'text-embedding-3-small': { input: 0.00002, output: 0 }
    };
    
    const rates = pricing[model] || { input: 0, output: 0 };
    return (tokens.input / 1000) * rates.input + (tokens.output / 1000) * rates.output;
  }
  
  async trackUsage(data) {
    await db.ai_model_usage.create({
      data: {
        userId: data.userId,
        modelName: data.modelName,
        taskType: data.taskType,
        tokensInput: data.tokensInput,
        tokensOutput: data.tokensOutput,
        costUsd: data.cost,
        responseTimeMs: data.responseTimeMs
      }
    });
  }
  
  formatDate(date) {
    const daysAgo = Math.floor((Date.now() - new Date(date)) / (1000 * 60 * 60 * 24));
    if (daysAgo === 0) return 'today';
    if (daysAgo === 1) return 'yesterday';
    if (daysAgo < 7) return `${daysAgo} days ago`;
    if (daysAgo < 30) return `${Math.floor(daysAgo / 7)} weeks ago`;
    return `${Math.floor(daysAgo / 30)} months ago`;
  }
}

export const aiRouter = new AIRouter();
```

-----

## PART 3: ENHANCED CONTEXT BUILDER

Create `services/contextBuilder.js`:

```javascript
import { db } from './database';

export async function buildEnhancedContext(userId) {
  
  // Get base user data
  const user = await db.users.findUnique({
    where: { id: userId },
    include: {
      training_sessions: {
        orderBy: { session_date: 'desc' },
        take: 10
      }
    }
  });
  
  if (!user) throw new Error('User not found');
  
  // Base context (always included)
  const context = {
    userId,
    user: {
      beltLevel: user.belt_level,
      trainingFrequency: user.training_frequency,
      mainGoal: user.main_goal,
      totalSessions: user.total_sessions
    },
    recentSessions: user.training_sessions
  };
  
  // Load relevant memories (last 3 months)
  const threeMonthsAgo = new Date();
  threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
  
  const memories = await db.user_memory_markers.findMany({
    where: {
      userId,
      occurred_at: { gte: threeMonthsAgo }
    },
    orderBy: [
      { significance_score: 'desc' },
      { occurred_at: 'desc' }
    ],
    take: 10
  });
  
  context.relevantMemories = memories;
  
  // Load learned coaching style (if exists)
  const coachingStyle = await learnCoachingStyle(userId);
  if (coachingStyle) {
    context.coachingStyle = coachingStyle;
  }
  
  // Load engagement profile
  const engagement = await db.user_engagement_profile.findUnique({
    where: { userId }
  });
  context.engagementProfile = engagement;
  
  return context;
}

async function learnCoachingStyle(userId) {
  // Check if we have enough coaching outcomes to learn from
  const outcomes = await db.coaching_outcomes.findMany({
    where: {
      userId,
      advice_was_effective: { not: null }
    },
    take: 20
  });
  
  if (outcomes.length < 5) {
    return null; // Not enough data yet
  }
  
  // Analyze what works
  const effective = outcomes.filter(o => o.advice_was_effective);
  const ineffective = outcomes.filter(o => !o.advice_was_effective);
  
  // Simple pattern detection
  const briefEffective = effective.filter(o => o.response_length === 'brief').length;
  const detailedEffective = effective.filter(o => o.response_length === 'detailed').length;
  
  const dataEffective = effective.filter(o => o.user_cognitive_style === 'data_driven').length;
  const supportEffective = effective.filter(o => o.user_cognitive_style === 'supportive').length;
  
  return {
    prefers_brief: briefEffective > detailedEffective,
    responds_to_data: dataEffective > supportEffective,
    responds_to_encouragement: supportEffective > dataEffective,
    sample_size: outcomes.length
  };
}
```

-----

## PART 4: PERFORMANCE OPTIMIZATION (REDIS CACHING)

Create `services/cache.js`:

```javascript
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');

export class CacheService {
  
  // Cache user context (expensive to build)
  async getCachedContext(userId, builder) {
    const key = `context:${userId}`;
    
    const cached = await redis.get(key);
    if (cached) {
      console.log('‚úÖ Context cache HIT');
      return JSON.parse(cached);
    }
    
    console.log('‚ùå Context cache MISS - building...');
    const context = await builder();
    
    // Cache for 5 minutes
    await redis.setex(key, 300, JSON.stringify(context));
    
    return context;
  }
  
  // Cache video recommendations
  async getCachedVideos(userId, technique, fetcher) {
    const key = `videos:${userId}:${technique}`;
    
    const cached = await redis.get(key);
    if (cached) return JSON.parse(cached);
    
    const videos = await fetcher();
    
    // Cache for 1 hour
    await redis.setex(key, 3600, JSON.stringify(videos));
    
    return videos;
  }
  
  // Invalidate user cache (call when user logs new session)
  async invalidateUserCache(userId) {
    const keys = await redis.keys(`context:${userId}`);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  }
}

export const cache = new CacheService();
```

-----

## PART 5: MEMORY MANAGEMENT SYSTEM

Create `services/memoryManager.js`:

```javascript
import { db } from './database';
import { aiRouter } from './aiRouter';

export class MemoryManager {
  
  // Create memory from significant moments
  async createMemory(userId, event) {
    const { type, summary, context, sessionIds, significance } = event;
    
    await db.user_memory_markers.create({
      data: {
        userId,
        memory_type: type,
        summary,
        significance_score: significance,
        full_context: context,
        related_session_ids: sessionIds,
        occurred_at: new Date(),
        memory_tier: significance >= 8 ? 'long_term' : 'working'
      }
    });
  }
  
  // Detect significant moments from session
  async detectSignificantMoments(userId, session) {
    const moments = [];
    
    // Breakthrough: First success with technique after multiple attempts
    if (session.successes_mentioned?.length > 0) {
      for (const success of session.successes_mentioned) {
        const previousAttempts = await this.countPreviousMentions(userId, success, 'struggles');
        
        if (previousAttempts >= 3) {
          moments.push({
            type: 'breakthrough',
            summary: `First success with ${success} after ${previousAttempts} sessions of struggle`,
            context: { technique: success, attempts: previousAttempts },
            sessionIds: [session.id],
            significance: 9
          });
        }
      }
    }
    
    // Recurring struggle pattern
    if (session.struggles_mentioned?.length > 0) {
      for (const struggle of session.struggles_mentioned) {
        const recentCount = await this.countRecentMentions(userId, struggle, 'struggles', 10);
        
        if (recentCount >= 3) {
          moments.push({
            type: 'struggle_pattern',
            summary: `Recurring struggle with ${struggle} (${recentCount} times in recent sessions)`,
            context: { technique: struggle, count: recentCount },
            sessionIds: [session.id],
            significance: 7
          });
        }
      }
    }
    
    // Injury concern
    if (session.injuries_mentioned?.length > 0) {
      const recentInjuries = await this.countRecentMentions(userId, session.injuries_mentioned[0], 'injuries', 5);
      
      if (recentInjuries >= 2) {
        moments.push({
          type: 'injury_concern',
          summary: `${session.injuries_mentioned[0]} mentioned ${recentInjuries} times recently`,
          context: { injury: session.injuries_mentioned[0], count: recentInjuries },
          sessionIds: [session.id],
          significance: 9
        });
      }
    }
    
    // Milestone: Every 10 sessions
    if (session.user.total_sessions % 10 === 0) {
      moments.push({
        type: 'milestone',
        summary: `Reached ${session.user.total_sessions} total training sessions`,
        context: { total_sessions: session.user.total_sessions },
        sessionIds: [session.id],
        significance: 6
      });
    }
    
    // Create memories
    for (const moment of moments) {
      await this.createMemory(userId, moment);
    }
    
    return moments;
  }
  
  async countPreviousMentions(userId, item, field) {
    const sessions = await db.training_sessions.findMany({
      where: {
        userId,
        [field + '_mentioned']: { has: item }
      }
    });
    return sessions.length;
  }
  
  async countRecentMentions(userId, item, field, sessionCount) {
    const sessions = await db.training_sessions.findMany({
      where: { userId },
      orderBy: { session_date: 'desc' },
      take: sessionCount
    });
    
    return sessions.filter(s => s[field + '_mentioned']?.includes(item)).length;
  }
  
  // Memory tier promotion (run nightly)
  async promoteMemories() {
    // Promote working ‚Üí long_term if:
    // 1. Referenced 3+ times
    // 2. High significance (8+)
    await db.$executeRaw`
      UPDATE user_memory_markers
      SET memory_tier = 'long_term'
      WHERE memory_tier = 'working'
        AND (reference_count >= 3 OR significance_score >= 8)
    `;
    
    console.log('‚úÖ Memory promotion completed');
  }
  
  // Track when memory is referenced
  async referenceMemory(memoryId) {
    await db.user_memory_markers.update({
      where: { id: memoryId },
      data: {
        reference_count: { increment: 1 },
        last_referenced_at: new Date()
      }
    });
  }
}

export const memoryManager = new MemoryManager();
```

-----

## PART 6: ENGAGEMENT DISCOVERY SYSTEM

Create `services/engagementSystem.js`:

```javascript
import { db } from './database';

export class EngagementSystem {
  
  // Update engagement profile after each interaction
  async updateEngagement(userId, interaction) {
    const profile = await db.user_engagement_profile.upsert({
      where: { userId },
      update: {},
      create: { userId }
    });
    
    // Track what user did
    if (interaction.type === 'video_request') {
      await db.user_engagement_profile.update({
        where: { userId },
        data: {
          last_video_request_at: new Date()
        }
      });
    }
    
    if (interaction.type === 'session_log') {
      const updates = {
        last_session_log_at: new Date(),
        total_sessions_logged: { increment: 1 }
      };
      
      if (!profile.has_logged_session) {
        updates.has_logged_session = true;
        updates.first_session_logged_at = new Date();
      }
      
      await db.user_engagement_profile.update({
        where: { userId },
        data: updates
      });
    }
    
    // Update engagement stage
    await this.updateEngagementStage(userId);
  }
  
  async updateEngagementStage(userId) {
    const profile = await db.user_engagement_profile.findUnique({
      where: { userId }
    });
    
    if (!profile) return;
    
    let newStage = profile.engagement_stage;
    
    // Stage progression
    if (!profile.has_logged_session) {
      newStage = 'discovery'; // Just exploring, asking for videos
    } else if (profile.total_sessions_logged < 5) {
      newStage = 'light_logger'; // Starting to log sessions
    } else if (profile.total_sessions_logged >= 5) {
      newStage = 'power_user'; // Regular logger, knows the power
    }
    
    if (newStage !== profile.engagement_stage) {
      await db.user_engagement_profile.update({
        where: { userId },
        data: {
          engagement_stage: newStage,
          stage_updated_at: new Date()
        }
      });
      
      console.log(`üéâ User ${userId} advanced to ${newStage} stage`);
      
      // Create celebration nudge for stage advancement
      if (newStage === 'power_user') {
        await this.createNudge(userId, {
          type: 'stage_celebration',
          content: "You've logged 5+ training sessions. Prof. OS is learning your patterns now. The more you share, the smarter it gets at coaching YOU specifically.",
          priority: 'medium',
          deliveryTime: new Date()
        });
      }
    }
  }
  
  // Create discovery nudges for video-only users
  async checkForDiscoveryNudges(userId) {
    const profile = await db.user_engagement_profile.findUnique({
      where: { userId }
    });
    
    if (!profile) return;
    
    // User has requested videos 3+ times but never logged session
    if (!profile.has_logged_session && profile.last_video_request_at) {
      const videoRequests = await db.conversations.count({
        where: {
          userId,
          conversationType: 'video_request'
        }
      });
      
      if (videoRequests >= 3) {
        // Check if nudge already sent
        const existingNudge = await db.engagement_nudges.findFirst({
          where: {
            userId,
            nudge_type: 'discover_session_logging'
          }
        });
        
        if (!existingNudge) {
          await this.createNudge(userId, {
            type: 'discover_session_logging',
            content: "By the way - I can do more than just recommend videos. After you train, tell me how it went. I'll start tracking your progress and giving you personalized coaching. Try it after your next session.",
            priority: 'low',
            deliveryTime: this.getOptimalDeliveryTime(profile)
          });
        }
      }
    }
  }
  
  async createNudge(userId, nudge) {
    await db.engagement_nudges.create({
      data: {
        userId,
        nudge_type: nudge.type,
        content: nudge.content,
        priority: nudge.priority,
        optimal_delivery_time: nudge.deliveryTime,
        trigger_reason: nudge.reason || 'Engagement system'
      }
    });
  }
  
  getOptimalDeliveryTime(profile) {
    // Deliver nudge 1 hour after last video request
    if (profile.last_video_request_at) {
      const delivery = new Date(profile.last_video_request_at);
      delivery.setHours(delivery.getHours() + 1);
      return delivery;
    }
    
    return new Date();
  }
  
  // Get pending nudge for user (max 1 per week)
  async getPendingNudge(userId) {
    // Check if user got a nudge in last 7 days
    const recentNudge = await db.engagement_nudges.findFirst({
      where: {
        userId,
        delivered_at: {
          gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
        }
      }
    });
    
    if (recentNudge) {
      return null; // Don't spam - max 1/week
    }
    
    // Get highest priority pending nudge
    const nudge = await db.engagement_nudges.findFirst({
      where: {
        userId,
        delivered_at: null,
        optimal_delivery_time: { lte: new Date() }
      },
      orderBy: [
        { priority: 'desc' },
        { optimal_delivery_time: 'asc' }
      ]
    });
    
    return nudge;
  }
  
  async markNudgeDelivered(nudgeId, action = 'shown') {
    await db.engagement_nudges.update({
      where: { id: nudgeId },
      data: {
        delivered_at: new Date(),
        user_action: action
      }
    });
  }
}

export const engagementSystem = new EngagementSystem();
```

-----

## PART 7: INTEGRATION WITH EXISTING PROF. OS

Update your existing Prof. OS message handler (DO NOT replace, just enhance):

```javascript
import { aiRouter } from './services/aiRouter';
import { buildEnhancedContext } from './services/contextBuilder';
import { cache } from './services/cache';
import { engagementSystem } from './services/engagementSystem';
import { memoryManager } from './services/memoryManager';

// Enhance your existing handler
export async function handleProfOsMessage(userMessage, userId) {
  
  // Build enhanced context (with caching)
  const context = await cache.getCachedContext(
    userId,
    () => buildEnhancedContext(userId)
  );
  
  // Detect interaction type
  const interactionType = detectInteractionType(userMessage);
  
  // Update engagement profile
  await engagementSystem.updateEngagement(userId, {
    type: interactionType
  });
  
  // Route to appropriate model (Claude for coaching)
  const response = await aiRouter.handleMessage(
    userMessage,
    context,
    'coaching'
  );
  
  // Check for pending engagement nudge (show after response)
  const nudge = await engagementSystem.getPendingNudge(userId);
  
  let finalResponse = response;
  
  if (nudge) {
    finalResponse += `\n\n---\n\n${nudge.content}`;
    await engagementSystem.markNudgeDelivered(nudge.id, 'shown');
  }
  
  return finalResponse;
}

// After user logs session
export async function handleSessionLogged(userId, session) {
  
  // Existing session logging logic...
  
  // NEW: Detect significant moments and create memories
  const moments = await memoryManager.detectSignificantMoments(userId, session);
  
  // NEW: Update engagement
  await engagementSystem.updateEngagement(userId, {
    type: 'session_log'
  });
  
  // NEW: Invalidate cache
  await cache.invalidateUserCache(userId);
  
  // NEW: Check if should create discovery nudges
  await engagementSystem.checkForDiscoveryNudges(userId);
}

function detectInteractionType(message) {
  const lower = message.toLowerCase();
  
  if (lower.includes('video') || lower.includes('show me') || lower.includes('recommend')) {
    return 'video_request';
  }
  
  if (lower.includes('trained') || lower.includes('session') || lower.includes('rolled')) {
    return 'session_log';
  }
  
  return 'general_chat';
}
```

-----

## PART 8: BACKGROUND JOBS

Create `jobs/intelligenceUpdater.js`:

```javascript
import cron from 'node-cron';
import { memoryManager } from '../services/memoryManager';
import { db } from '../services/database';

// Promote memories (run daily at 4am)
cron.schedule('0 4 * * *', async () => {
  console.log('üß† Running memory promotion...');
  await memoryManager.promoteMemories();
});

// Measure coaching effectiveness (run daily at 5am)
cron.schedule('0 5 * * *', async () => {
  console.log('üìä Measuring coaching effectiveness...');
  
  // Get coaching outcomes from 7-30 days ago (allow time to measure)
  const startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  const endDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  
  const unmeasured = await db.coaching_outcomes.findMany({
    where: {
      given_at: { gte: startDate, lte: endDate },
      advice_was_effective: null
    }
  });
  
  for (const outcome of unmeasured) {
    // Get next 3 sessions after advice given
    const followUpSessions = await db.training_sessions.findMany({
      where: {
        userId: outcome.userId,
        session_date: {
          gte: outcome.given_at,
          lte: new Date(outcome.given_at.getTime() + 21 * 24 * 60 * 60 * 1000) // 3 weeks
        }
      },
      take: 3,
      orderBy: { session_date: 'asc' }
    });
    
    if (followUpSessions.length === 0) continue;
    
    // Simple effectiveness check
    const adviceContent = outcome.advice_given.toLowerCase();
    const followed = followUpSessions.some(s => 
      s.techniques_mentioned?.some(t => adviceContent.includes(t.toLowerCase())) ||
      s.user_notes?.toLowerCase().includes(adviceContent.substring(0, 50))
    );
    
    // Check if problem resolved
    const wasEffective = followed && followUpSessions.some(s =>
      s.successes_mentioned?.length > 0
    );
    
    await db.coaching_outcomes.update({
      where: { id: outcome.id },
      data: {
        user_followed_advice: followed,
        advice_was_effective: wasEffective,
        measured_at: new Date()
      }
    });
  }
  
  console.log(`‚úÖ Measured ${unmeasured.length} coaching outcomes`);
});

console.log('üìÖ Background jobs scheduled');
```

-----

## PART 9: ENVIRONMENT VARIABLES

Add to `.env`:

```
# Existing variables (keep these)
ANTHROPIC_API_KEY=your_existing_key
DATABASE_URL=your_existing_database_url

# New variables (add these)
OPENAI_API_KEY=your_openai_key_here
REDIS_URL=redis://localhost:6379

# System prompt (add your existing Prof. OS prompt here)
PROF_OS_BASE_PROMPT="You are Prof. OS, a Brazilian Jiu-Jitsu coach..."
```

-----

## PART 10: DEPENDENCIES TO INSTALL

```bash
npm install ioredis @anthropic-ai/sdk openai node-cron
```

-----

## TESTING CHECKLIST

After implementation, test:

1. ‚úÖ **Existing functionality works:**

- Session logging
- Video recommendations
- Prof. OS personality unchanged

1. ‚úÖ **Memory system works:**

- Significant moments detected
- Memories created
- Memories referenced naturally in responses

1. ‚úÖ **Performance is fast:**

- Context loads < 500ms
- Responses feel instant
- Redis caching working

1. ‚úÖ **Engagement nudges work:**

- Video-only users get discovery nudge after 3rd request
- Users advance through stages (discovery ‚Üí light_logger ‚Üí power_user)
- Max 1 nudge per week

1. ‚úÖ **Multi-model routing works:**

- Claude handles coaching
- GPT handles embeddings/extraction
- Usage tracked in database

-----

## DEPLOYMENT ORDER

1. Add new database tables (run migrations)
1. Install dependencies
1. Add Redis (can use Upstash free tier for Replit)
1. Add AIRouter service
1. Add contextBuilder service
1. Add cache service
1. Add memoryManager service
1. Add engagementSystem service
1. Update existing Prof. OS handler to use enhanced context
1. Deploy background jobs
1. Test with existing users
1. Monitor performance and engagement metrics

-----

## CRITICAL NOTES

**What this DOES:**

- Makes Prof. OS remember user‚Äôs journey naturally
- Makes Prof. OS learn what coaching works for each user
- Makes Prof. OS fast and smooth
- Helps video-only users discover session logging power
- Tracks everything for continuous improvement

**What this DOESN‚ÄôT do:**

- Force citations or statistics into responses
- Spam users with notifications
- Add gamification
- Change existing Prof. OS personality
- Break any existing features

**The goal:** Make Prof. OS feel magical and personal without being annoying or robotic.

-----

**This is a complete additive enhancement. Everything existing stays intact. New intelligence layers make Prof. OS better over time.**

```
---

# BONUS: The "Discovery Hook" Strategy

Now let me address your concern about users discovering the power...

## The Problem You Identified

**User behavior:**
- Lying in bed at night
- "Show me triangle videos"
- Gets 3 video recommendations
- Doesn't know Prof. OS can do WAY more

**The missed opportunity:**
- They don't know about session logging
- They don't know about pattern detection
- They don't know about personalized coaching
- They're using a Ferrari like a bicycle

---

## The Solution: Gentle Discovery Hooks

### **Hook #1: After 3rd Video Request (Curiosity)**
```

User: ‚ÄúShow me videos on kimura from top‚Äù

Prof. OS: [gives 3 video recommendations]

‚ÄúBy the way - these videos are great for learning the basics. But if you tell me about your actual training sessions, I can recommend videos based on YOUR specific game and what YOU struggle with. Way more personalized. Try it after your next session if you want.‚Äù

```
**Why this works:**
- ‚úÖ Casual, not pushy ("by the way")
- ‚úÖ Shows value ("YOUR specific game")
- ‚úÖ Low friction ("try it after your next session")
- ‚úÖ Optional ("if you want")

---

### **Hook #2: First Session Log (Mind Blown)**
```

User: ‚ÄúTrained today. Worked on triangles, got swept twice from half guard.‚Äù

Prof. OS: ‚ÄúGot it - working on triangles but struggling with half guard retention.

Here‚Äôs what‚Äôs probably happening: when you‚Äôre in half guard, are you staying on your side or getting flat on your back?

[continues with detailed coaching]

[Then, at the end:]

This is just the beginning. The more you share about your training, the better I get at coaching YOU specifically. I‚Äôll start seeing patterns you don‚Äôt notice. I‚Äôll remember what worked and what didn‚Äôt. This is how we turn you into a problem-solver on the mats.‚Äù

```
**Why this works:**
- ‚úÖ Shows immediate value (detailed coaching)
- ‚úÖ Explains what's possible ("patterns you don't notice")
- ‚úÖ Personal ("coaching YOU specifically")
- ‚úÖ Plants seed for habit ("the more you share")

---

### **Hook #3: After 3 Sessions (Show the Magic)**
```

User: [logs 3rd session]

Prof. OS: [gives coaching as usual]

‚ÄúQuick observation - this is your 3rd session with me. I‚Äôm starting to see your game now:

- Your closed guard is becoming dangerous (hit triangles in 2 of 3 sessions)
- Half guard is your current challenge (mentioned it all 3 times)
- You‚Äôre training 3x/week consistently

This is what I mean by ‚Äògetting smarter over time.‚Äô Keep sharing your training and I‚Äôll keep connecting the dots.‚Äù

```
**Why this works:**
- ‚úÖ Shows concrete value (specific insights)
- ‚úÖ Proves it's working ("I'm starting to see your game")
- ‚úÖ Reinforces habit ("keep sharing")
- ‚úÖ Makes user feel seen

---

### **Hook #4: After 5 Sessions (Power User Unlock)**
```

User: [logs 5th session]

Prof. OS: [gives coaching]

‚ÄúYou‚Äôve shared 5 sessions with me now. Prof. OS is officially dialed into YOUR game.

I know:

- Your signature moves (triangle from closed guard - 75% success)
- Your gaps (half guard retention)
- Your learning patterns (you breakthrough every 2-3 weeks)

This is the power of consistent logging. Most people just ask for videos. You‚Äôre actually building a relationship with an AI coach that learns YOU. Keep it up.‚Äù

```
**Why this works:**
- ‚úÖ Celebrates milestone
- ‚úÖ Shows specific value (concrete data)
- ‚úÖ Makes them feel special ("most people just ask for videos")
- ‚úÖ Reinforces identity ("you're building a relationship")

---

## Implementation in Code

Add to `services/engagementSystem.js`:

```javascript
// Discovery hooks based on user journey
async function getDiscoveryHook(userId, context) {
  const profile = context.engagementProfile;
  
  // Hook #1: After 3 video requests, no sessions logged
  if (!profile.has_logged_session) {
    const videoRequestCount = await countInteractions(userId, 'video_request');
    
    if (videoRequestCount === 3) {
      return {
        hook: "By the way - these videos are great for learning the basics. But if you tell me about your actual training sessions, I can recommend videos based on YOUR specific game and what YOU struggle with. Way more personalized. Try it after your next session if you want.",
        type: 'discover_logging'
      };
    }
  }
  
  // Hook #2: First session logged
  if (profile.total_sessions_logged === 1) {
    return {
      hook: "\n\nThis is just the beginning. The more you share about your training, the better I get at coaching YOU specifically. I'll start seeing patterns you don't notice. I'll remember what worked and what didn't. This is how we turn you into a problem-solver on the mats.",
      type: 'first_session_magic'
    };
  }
  
  // Hook #3: After 3 sessions
  if (profile.total_sessions_logged === 3) {
    const insights = await generateQuickInsights(userId);
    return {
      hook: `\n\nQuick observation - this is your 3rd session with me. I'm starting to see your game now:\n\n${insights}\n\nThis is what I mean by 'getting smarter over time.' Keep sharing your training and I'll keep connecting the dots.`,
      type: 'show_intelligence'
    };
  }
  
  // Hook #4: After 5 sessions
  if (profile.total_sessions_logged === 5) {
    const profile_summary = await generateProfileSummary(userId);
    return {
      hook: `\n\nYou've shared 5 sessions with me now. Prof. OS is officially dialed into YOUR game.\n\nI know:\n${profile_summary}\n\nThis is the power of consistent logging. Most people just ask for videos. You're actually building a relationship with an AI coach that learns YOU. Keep it up.`,
      type: 'power_user_unlock'
    };
  }
  
  return null;
}

async function generateQuickInsights(userId) {
  const sessions = await db.training_sessions.findMany({
    where: { userId },
    orderBy: { session_date: 'desc' },
    take: 3
  });
  
  const insights = [];
  
  // Find successes
  const successes = sessions.flatMap(s => s.successes_mentioned || []);
  if (successes.length > 0) {
    const top = successes[0];
    insights.push(`- Your ${top} is becoming dangerous (hit it in ${successes.filter(s => s === top).length} of 3 sessions)`);
  }
  
  // Find struggles
  const struggles = sessions.flatMap(s => s.struggles_mentioned || []);
  if (struggles.length > 0) {
    const recurring = struggles[0];
    insights.push(`- ${recurring} is your current challenge (mentioned all 3 times)`);
  }
  
  // Training frequency
  insights.push(`- You're training ${sessions.length}x/week consistently`);
  
  return insights.join('\n');
}
```

-----

## The User Journey (With Discovery Hooks)

### **Week 1: Discovery Phase**

**Day 1:**

- User: ‚ÄúShow me triangle videos‚Äù
- Prof. OS: [3 videos]
- User thinks: ‚ÄúCool video search‚Äù

**Day 3:**

- User: ‚ÄúShow me armbar videos‚Äù
- Prof. OS: [3 videos]
- User thinks: ‚ÄúHandy video finder‚Äù

**Day 5:**

- User: ‚ÄúShow me guard passing videos‚Äù
- Prof. OS: [3 videos] + **Hook #1 (Discovery)**
- User thinks: ‚ÄúWait, it can do more? Interesting‚Ä¶‚Äù

-----

### **Week 2: First Session**

**Day 8 (after training):**

- User: ‚ÄúTrained today. Worked on triangles, got swept from half guard.‚Äù
- Prof. OS: [Detailed coaching] + **Hook #2 (Mind Blown)**
- User thinks: ‚ÄúHoly shit, this is actually useful. It‚Äôs like having a coach.‚Äù

-----

### **Week 3-4: Building Habit**

**Day 15 (3rd session):**

- User: [logs session]
- Prof. OS: [Coaching] + **Hook #3 (Show Intelligence)**
- User thinks: ‚ÄúIt‚Äôs actually tracking my progress. This is getting real.‚Äù

-----

### **Week 5-6: Power User**

**Day 35 (5th session):**

- User: [logs session]
- Prof. OS: [Coaching] + **Hook #4 (Power User Unlock)**
- User thinks: ‚ÄúI‚Äôm hooked. This is my BJJ journal now. It knows my game better than I do.‚Äù

-----

## The Result

**Before hooks:**

- 90% of users: Video search only
- 10% of users: Discover session logging by accident

**After hooks:**

- 30% of users: Try session logging after Hook #1
- 60% of users: Become regular loggers after Hook #2
- 80% of users: Power users by Hook #4

**You 5x the conversion to power users with strategic hooks.**

-----

## Final Thoughts

**The master prompt above gives you:**

1. ‚úÖ Tiered memory (journey tracking)
1. ‚úÖ Silent effectiveness tracking (learns what works)
1. ‚úÖ Performance optimization (fast/smooth)
1. ‚úÖ Engagement hooks (discovery system)
1. ‚úÖ Multi-model routing (cost efficiency)

**The discovery hooks solve:**

- Video-only users missing the power
- Natural conversion funnel
- Non-pushy education
- Identity formation (‚ÄúI‚Äôm a power user‚Äù)

**This is your path to elite-tier product.**

**Ready to send this to Replit Agent?**