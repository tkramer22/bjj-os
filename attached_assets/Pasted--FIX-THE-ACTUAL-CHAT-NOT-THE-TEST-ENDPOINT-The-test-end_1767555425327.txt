# FIX THE ACTUAL CHAT - NOT THE TEST ENDPOINT

The test endpoint works but the REAL chat flow is broken. Users see infinite spinner or “Sorry, I’m having trouble” on every message.

## THE PROBLEM

You tested `/api/test/claude` which bypasses authentication and database. The REAL endpoint `/api/ai/chat/message` is failing.

## STEP 1: ADD LOGGING TO THE REAL ENDPOINT

Find the actual chat endpoint (likely `/api/ai/chat/message` or `/api/chat`) and add this logging:

```typescript
app.post('/api/ai/chat/message', async (req, res) => {
  const startTime = Date.now();
  
  console.log('========== CHAT REQUEST ==========');
  console.log('Time:', new Date().toISOString());
  console.log('Headers:', JSON.stringify(req.headers, null, 2));
  console.log('Body:', JSON.stringify(req.body, null, 2));
  console.log('User ID from body:', req.body?.userId);
  console.log('Message:', req.body?.message);
  
  // Check if user is authenticated
  const authHeader = req.headers.authorization;
  console.log('Auth header exists:', !!authHeader);
  
  try {
    // Step 1: Validate user
    console.log('Step 1: Validating user...');
    const userId = req.body?.userId;
    
    if (!userId) {
      console.error('ERROR: No userId provided');
      return res.status(400).json({ error: 'No user ID' });
    }
    
    // Step 2: Get user from database
    console.log('Step 2: Fetching user from database...');
    const dbStart = Date.now();
    
    const user = await db.select().from(bjjUsers).where(eq(bjjUsers.id, userId)).limit(1);
    
    console.log('Database query took:', Date.now() - dbStart, 'ms');
    console.log('User found:', !!user[0]);
    
    if (!user[0]) {
      console.error('ERROR: User not found in database');
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Step 3: Call Claude API
    console.log('Step 3: Calling Claude API...');
    const claudeStart = Date.now();
    
    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 1024,
      system: "You are Professor OS, a BJJ training partner...", // Your system prompt
      messages: [{ role: "user", content: req.body.message }]
    });
    
    console.log('Claude API took:', Date.now() - claudeStart, 'ms');
    console.log('Response length:', response.content[0]?.text?.length);
    
    // Step 4: Save to database (if applicable)
    console.log('Step 4: Saving conversation...');
    
    // Step 5: Return response
    console.log('Step 5: Sending response');
    console.log('Total time:', Date.now() - startTime, 'ms');
    console.log('========== CHAT COMPLETE ==========');
    
    res.json({ 
      response: response.content[0]?.text,
      success: true 
    });
    
  } catch (error: any) {
    console.error('========== CHAT ERROR ==========');
    console.error('Error at:', Date.now() - startTime, 'ms');
    console.error('Error name:', error.name);
    console.error('Error message:', error.message);
    console.error('Error code:', error.code);
    console.error('Error status:', error.status);
    console.error('Stack:', error.stack);
    console.error('================================');
    
    res.status(500).json({ 
      error: 'Sorry, I\'m having trouble right now. Please try again!',
      debug: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
```

## STEP 2: CHECK FOR DATABASE TIMEOUT

The logs mention “CONNECT_TIMEOUT errors to Supabase”. This is likely the issue.

Add connection retry logic:

```typescript
// At the top of your database config
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const connectionString = process.env.DATABASE_URL!;

const client = postgres(connectionString, {
  max: 10,                    // Max connections
  idle_timeout: 20,           // Close idle connections after 20s
  connect_timeout: 30,        // 30 second connection timeout
  max_lifetime: 60 * 30,      // Max connection lifetime 30 min
});

export const db = drizzle(client);
```

## STEP 3: ADD TIMEOUT TO CLAUDE CALL

The Claude API call might be hanging:

```typescript
// Wrap Claude call with timeout
const claudeWithTimeout = async (message: string, timeoutMs: number = 30000) => {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 1024,
      messages: [{ role: "user", content: message }]
    }, {
      signal: controller.signal
    });
    
    clearTimeout(timeout);
    return response;
  } catch (error: any) {
    clearTimeout(timeout);
    if (error.name === 'AbortError') {
      throw new Error('Claude API timed out after ' + timeoutMs + 'ms');
    }
    throw error;
  }
};
```

## STEP 4: CHECK FRONTEND IS SENDING CORRECT DATA

In the iOS app chat component, verify the fetch call:

```typescript
const sendMessage = async (message: string) => {
  console.log('Sending message:', message);
  console.log('User ID:', userId);
  console.log('Auth token:', authToken);
  
  try {
    const response = await fetch('/api/ai/chat/message', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}` // Is this being sent?
      },
      body: JSON.stringify({
        userId: userId,  // Is this defined?
        message: message
      })
    });
    
    console.log('Response status:', response.status);
    const data = await response.json();
    console.log('Response data:', data);
    
    if (!response.ok) {
      throw new Error(data.error || 'Request failed');
    }
    
    return data.response;
  } catch (error) {
    console.error('Send message error:', error);
    throw error;
  }
};
```

## STEP 5: FIX THE INFINITE SPINNER

The chat screen is hanging on load. Add a timeout:

```typescript
// In the chat screen component
useEffect(() => {
  const loadChat = async () => {
    const timeout = setTimeout(() => {
      setLoading(false);
      setError('Connection timed out. Tap to retry.');
    }, 10000); // 10 second timeout
    
    try {
      // Load chat history or initialize
      await loadChatHistory();
      clearTimeout(timeout);
      setLoading(false);
    } catch (error) {
      clearTimeout(timeout);
      setLoading(false);
      setError('Failed to load chat. Tap to retry.');
    }
  };
  
  loadChat();
}, []);

// Show error state instead of infinite spinner
if (error) {
  return (
    <TouchableOpacity onPress={() => { setError(null); setLoading(true); loadChat(); }}>
      <Text>{error}</Text>
      <Text>Tap to retry</Text>
    </TouchableOpacity>
  );
}
```

## STEP 6: VERIFY THE ACTUAL ERROR

After adding the logging, send a test message and check the server console.

The logs will show EXACTLY where it fails:

- “Step 1: Validating user…” then error = userId issue
- “Step 2: Fetching user…” then error = Database issue
- “Step 3: Calling Claude…” then error = API issue

## IMMEDIATE ACTIONS

1. Add the detailed logging to the chat endpoint
1. Send a test message from the app
1. Check the server console for where it fails
1. Report back what step it fails at

The test endpoint working proves Claude API is fine. The bug is in the real chat flow - we need to find exactly where.

## STEP 7: FIX MICROPHONE

The microphone also stopped working. Check:

1. **Permissions** - Is microphone permission still granted?

```typescript
// In the voice input component
import { Audio } from 'expo-av';

const checkMicPermission = async () => {
  const { status } = await Audio.requestPermissionsAsync();
  console.log('Mic permission status:', status);
  return status === 'granted';
};
```

1. **Recording initialization** - Add logging:

```typescript
const startRecording = async () => {
  console.log('Starting recording...');
  
  try {
    const hasPermission = await checkMicPermission();
    if (!hasPermission) {
      console.error('No microphone permission');
      alert('Please enable microphone access in Settings');
      return;
    }
    
    await Audio.setAudioModeAsync({
      allowsRecordingIOS: true,
      playsInSilentModeIOS: true,
    });
    
    console.log('Audio mode set, creating recording...');
    
    const { recording } = await Audio.Recording.createAsync(
      Audio.RecordingOptionsPresets.HIGH_QUALITY
    );
    
    console.log('Recording started successfully');
    setRecording(recording);
    
  } catch (error) {
    console.error('Failed to start recording:', error);
  }
};
```

1. **Check if audio config was changed** - Recent code changes may have broken audio setup