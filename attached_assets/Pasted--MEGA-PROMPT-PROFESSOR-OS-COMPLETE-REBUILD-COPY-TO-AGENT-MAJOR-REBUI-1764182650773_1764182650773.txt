# ğŸš€ **MEGA PROMPT: PROFESSOR OS COMPLETE REBUILD**

-----

## **ğŸ“‹ COPY TO AGENT**

```
MAJOR REBUILD: Professor OS Video System + Coaching Intelligence

Todd has approved a complete rebuild of the video recommendation system and Professor OS coaching personality.

Excellence is the pillar. This must be perfect.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 1: VIDEO TAXONOMY - RE-TAG ALL VIDEOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STEP 1: Add new columns to video table (if not exists)

```sql
ALTER TABLE ai_video_knowledge 
ADD COLUMN IF NOT EXISTS technique_type VARCHAR(20),
ADD COLUMN IF NOT EXISTS position_category VARCHAR(30),
ADD COLUMN IF NOT EXISTS gi_nogi VARCHAR(10) DEFAULT 'both',
ADD COLUMN IF NOT EXISTS tags TEXT[] DEFAULT '{}';

CREATE INDEX IF NOT EXISTS idx_videos_technique_type ON ai_video_knowledge(technique_type);
CREATE INDEX IF NOT EXISTS idx_videos_position_category ON ai_video_knowledge(position_category);
CREATE INDEX IF NOT EXISTS idx_videos_gi_nogi ON ai_video_knowledge(gi_nogi);
CREATE INDEX IF NOT EXISTS idx_videos_tags ON ai_video_knowledge USING GIN(tags);
```

STEP 2: The 4-Field Taxonomy (LOCKED IN)

technique_type (REQUIRED - every video must have one):

- attack = Submissions, sweeps, passes, takedowns
- defense = Escapes, counters, survival, retention
- concept = Principles, theory, strategy, fundamentals

position_category (REQUIRED - every video must have one):

- closed_guard
- open_guard (includes spider, lasso, DLR, butterfly, X-guard, etc.)
- half_guard (includes deep half, Z-guard, knee shield)
- mount
- side_control
- back
- standing (takedowns, wrestling, stand-up)
- turtle
- leg_entanglement (50/50, saddle, ashi, etc.)
- north_south
- knee_on_belly
- guard_passing (in the act of passing, not position-specific)
- universal (applies to multiple positions)

gi_nogi:

- gi = Requires gi grips
- nogi = No-gi specific
- both = Works in either

tags (array of searchable keywords):

- Specific technique names: [â€œhip bump sweepâ€, â€œkimuraâ€, â€œarm triangleâ€]
- Variations: [â€œno arm triangleâ€, â€œmounted triangleâ€]
- Concepts: [â€œpressureâ€, â€œframesâ€, â€œunderhookâ€]
- Attributes: [â€œbeginner friendlyâ€, â€œcompetition testedâ€]

STEP 3: Create AI Re-Tagging Script

Create file: scripts/retag-videos.ts

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { db } from '../db';
import { aiVideoKnowledge } from '../db/schema';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

const TAXONOMY = {
  technique_type: ['attack', 'defense', 'concept'],
  position_category: [
    'closed_guard', 'open_guard', 'half_guard', 'mount', 
    'side_control', 'back', 'standing', 'turtle', 
    'leg_entanglement', 'north_south', 'knee_on_belly', 
    'guard_passing', 'universal'
  ],
  gi_nogi: ['gi', 'nogi', 'both']
};

async function retagVideo(video: any) {
  const prompt = `You are a BJJ expert. Analyze this video and categorize it.

VIDEO TITLE: ${video.title}
INSTRUCTOR: ${video.instructorName}
CURRENT TECHNIQUE NAME: ${video.techniqueName || 'none'}
DESCRIPTION: ${video.description || 'none'}

CATEGORIZE WITH THESE EXACT VALUES:

1. technique_type (pick ONE):
   - "attack" = Submissions, sweeps, passes, takedowns, offensive moves
   - "defense" = Escapes, counters, survival, guard retention, defensive moves
   - "concept" = Principles, theory, strategy, fundamentals, not a specific technique

2. position_category (pick ONE - where does this technique primarily happen):
   - "closed_guard" = Inside or attacking closed guard
   - "open_guard" = Spider, lasso, DLR, butterfly, X-guard, SLX, etc.
   - "half_guard" = Half guard, deep half, Z-guard, knee shield
   - "mount" = Full mount, low mount
   - "side_control" = Side control, cross-side, 100 kilos
   - "back" = Back control, back mount, rear mount
   - "standing" = Takedowns, wrestling, judo, stand-up grappling
   - "turtle" = Turtle position, attacking or defending
   - "leg_entanglement" = 50/50, saddle, ashi garami, leg lock positions
   - "north_south" = North-south position
   - "knee_on_belly" = Knee on belly
   - "guard_passing" = The act of passing guard (not a static position)
   - "universal" = Applies broadly, not position-specific

3. gi_nogi (pick ONE):
   - "gi" = Requires gi grips (collars, sleeves, pants)
   - "nogi" = Specifically no-gi technique
   - "both" = Works in both gi and no-gi

4. tags (array of relevant searchable terms):
   - Include the specific technique name
   - Include variations or alternative names
   - Include key concepts
   - Include common search terms someone might use
   - 5-15 tags per video

RESPOND IN VALID JSON ONLY:
{
  "technique_type": "attack|defense|concept",
  "position_category": "one of the listed values",
  "gi_nogi": "gi|nogi|both",
  "tags": ["tag1", "tag2", "tag3"]
}`;

  try {
    const response = await anthropic.messages.create({
      model: "claude-sonnet-4-5-20250514",
      max_tokens: 500,
      messages: [{ role: 'user', content: prompt }]
    });

    const text = response.content[0].type === 'text' ? response.content[0].text : '';
    
    // Parse JSON from response
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) throw new Error('No JSON found in response');
    
    const result = JSON.parse(jsonMatch[0]);
    
    // Validate values
    if (!TAXONOMY.technique_type.includes(result.technique_type)) {
      throw new Error(`Invalid technique_type: ${result.technique_type}`);
    }
    if (!TAXONOMY.position_category.includes(result.position_category)) {
      throw new Error(`Invalid position_category: ${result.position_category}`);
    }
    if (!TAXONOMY.gi_nogi.includes(result.gi_nogi)) {
      throw new Error(`Invalid gi_nogi: ${result.gi_nogi}`);
    }
    
    return result;
  } catch (error) {
    console.error(`Error tagging video ${video.id}:`, error);
    return null;
  }
}

async function retagAllVideos() {
  console.log('Starting video re-tagging...');
  
  // Get all videos
  const videos = await db.select().from(aiVideoKnowledge);
  console.log(`Found ${videos.length} videos to process`);
  
  let success = 0;
  let failed = 0;
  
  for (let i = 0; i < videos.length; i++) {
    const video = videos[i];
    console.log(`[${i + 1}/${videos.length}] Processing: ${video.title}`);
    
    const tags = await retagVideo(video);
    
    if (tags) {
      await db.update(aiVideoKnowledge)
        .set({
          techniqueType: tags.technique_type,
          positionCategory: tags.position_category,
          giNogi: tags.gi_nogi,
          tags: tags.tags
        })
        .where(eq(aiVideoKnowledge.id, video.id));
      
      success++;
      console.log(`  âœ… Tagged: ${tags.technique_type} | ${tags.position_category} | ${tags.gi_nogi}`);
    } else {
      failed++;
      console.log(`  âŒ Failed to tag`);
    }
    
    // Rate limiting - 1 second between calls
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  console.log(`\nComplete! Success: ${success}, Failed: ${failed}`);
}

// Run the script
retagAllVideos();
```

Add to package.json:

```json
{
  "scripts": {
    "retag-videos": "npx tsx scripts/retag-videos.ts"
  }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 2: DYNAMIC VIDEO SEARCH
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replace the static 20-video pre-load with dynamic real-time search.

Create file: server/videoSearch.ts

```typescript
import { db } from '../db';
import { aiVideoKnowledge } from '../db/schema';
import { sql, desc, and, or, eq, arrayContains } from 'drizzle-orm';

interface VideoSearchParams {
  userMessage: string;
  conversationContext?: {
    sessionFocus?: Record<string, number>;
    recommendedVideoIds?: number[];
    userGiNogi?: string;
  };
}

interface VideoSearchResult {
  videos: any[];
  totalMatches: number;
}

// Extract search intent from user message
function extractSearchIntent(message: string): {
  techniqueType?: string;
  positionCategory?: string;
  searchTerms: string[];
} {
  const lowerMessage = message.toLowerCase();
  
  // Determine technique type
  let techniqueType: string | undefined;
  
  const defenseKeywords = ['escape', 'defense', 'defend', 'counter', 'get out', 'survival', 'retention', 'recover'];
  const attackKeywords = ['submit', 'submission', 'finish', 'attack', 'sweep', 'pass', 'choke', 'lock', 'takedown'];
  
  if (defenseKeywords.some(k => lowerMessage.includes(k))) {
    techniqueType = 'defense';
  } else if (attackKeywords.some(k => lowerMessage.includes(k))) {
    techniqueType = 'attack';
  }
  
  // Determine position category
  let positionCategory: string | undefined;
  
  const positionMap: Record<string, string> = {
    'closed guard': 'closed_guard',
    'open guard': 'open_guard',
    'spider guard': 'open_guard',
    'de la riva': 'open_guard',
    'dlr': 'open_guard',
    'butterfly': 'open_guard',
    'x guard': 'open_guard',
    'x-guard': 'open_guard',
    'lasso': 'open_guard',
    'half guard': 'half_guard',
    'deep half': 'half_guard',
    'z guard': 'half_guard',
    'z-guard': 'half_guard',
    'mount': 'mount',
    'mounted': 'mount',
    'side control': 'side_control',
    'side mount': 'side_control',
    'back control': 'back',
    'back mount': 'back',
    'rear mount': 'back',
    'standing': 'standing',
    'takedown': 'standing',
    'wrestling': 'standing',
    'turtle': 'turtle',
    'leg lock': 'leg_entanglement',
    'heel hook': 'leg_entanglement',
    'knee bar': 'leg_entanglement',
    '50/50': 'leg_entanglement',
    'ashi': 'leg_entanglement',
    'saddle': 'leg_entanglement',
    'north south': 'north_south',
    'knee on belly': 'knee_on_belly',
    'passing': 'guard_passing',
    'guard pass': 'guard_passing'
  };
  
  for (const [keyword, category] of Object.entries(positionMap)) {
    if (lowerMessage.includes(keyword)) {
      positionCategory = category;
      break;
    }
  }
  
  // Extract search terms (specific techniques)
  const techniquePatterns = [
    'armbar', 'arm bar', 'triangle', 'kimura', 'americana', 'omoplata',
    'guillotine', 'rear naked', 'rnc', 'arm triangle', 'darce', 'd\'arce',
    'anaconda', 'ezekiel', 'bow and arrow', 'collar choke', 'cross collar',
    'loop choke', 'baseball', 'north south choke',
    'hip bump', 'scissor sweep', 'flower sweep', 'pendulum',
    'knee slice', 'knee cut', 'torreando', 'over under', 'stack pass',
    'single leg', 'double leg', 'ankle pick',
    'heel hook', 'knee bar', 'toe hold', 'calf slicer',
    'berimbolo', 'kiss of the dragon',
    'shrimp', 'bridge', 'frame', 'underhook'
  ];
  
  const searchTerms: string[] = [];
  for (const technique of techniquePatterns) {
    if (lowerMessage.includes(technique)) {
      searchTerms.push(technique);
    }
  }
  
  // If no specific technique found, extract nouns
  if (searchTerms.length === 0) {
    const words = lowerMessage.split(/\s+/);
    const stopWords = ['the', 'a', 'an', 'for', 'on', 'in', 'with', 'show', 'me', 'video', 'videos', 'how', 'to', 'do', 'can', 'you', 'help', 'my', 'i', 'get', 'keep', 'getting'];
    const meaningful = words.filter(w => w.length > 3 && !stopWords.includes(w));
    searchTerms.push(...meaningful.slice(0, 3));
  }
  
  return { techniqueType, positionCategory, searchTerms };
}

export async function searchVideos(params: VideoSearchParams): Promise<VideoSearchResult> {
  const { userMessage, conversationContext } = params;
  const intent = extractSearchIntent(userMessage);
  
  // Build query conditions
  const conditions: any[] = [];
  
  // Quality floor - ALWAYS apply
  conditions.push(sql`${aiVideoKnowledge.qualityScore} >= 7.0`);
  
  // Exclude already recommended videos in this session
  if (conversationContext?.recommendedVideoIds?.length) {
    conditions.push(sql`${aiVideoKnowledge.id} NOT IN (${sql.join(conversationContext.recommendedVideoIds, sql`, `)})`);
  }
  
  // Filter by technique type if detected
  if (intent.techniqueType) {
    conditions.push(eq(aiVideoKnowledge.techniqueType, intent.techniqueType));
  }
  
  // Filter by position category if detected
  if (intent.positionCategory) {
    conditions.push(eq(aiVideoKnowledge.positionCategory, intent.positionCategory));
  }
  
  // Filter by gi/nogi preference
  if (conversationContext?.userGiNogi && conversationContext.userGiNogi !== 'both') {
    conditions.push(
      or(
        eq(aiVideoKnowledge.giNogi, conversationContext.userGiNogi),
        eq(aiVideoKnowledge.giNogi, 'both')
      )
    );
  }
  
  // Search by tags and title
  const searchConditions: any[] = [];
  for (const term of intent.searchTerms) {
    searchConditions.push(sql`${aiVideoKnowledge.title} ILIKE ${`%${term}%`}`);
    searchConditions.push(sql`${term} = ANY(${aiVideoKnowledge.tags})`);
    searchConditions.push(sql`${aiVideoKnowledge.techniqueName} ILIKE ${`%${term}%`}`);
  }
  
  if (searchConditions.length > 0) {
    conditions.push(or(...searchConditions));
  }
  
  // Execute search
  let query = db.select()
    .from(aiVideoKnowledge)
    .where(and(...conditions))
    .orderBy(desc(aiVideoKnowledge.qualityScore))
    .limit(20);
  
  let videos = await query;
  
  // Apply session focus boost
  if (conversationContext?.sessionFocus && videos.length > 0) {
    videos = videos.map(v => {
      let boost = 0;
      const tags = v.tags || [];
      
      for (const [topic, count] of Object.entries(conversationContext.sessionFocus!)) {
        if (tags.some((t: string) => t.toLowerCase().includes(topic.toLowerCase()))) {
          boost += count * 2;
        }
        if (v.positionCategory?.includes(topic)) {
          boost += count * 3;
        }
      }
      
      return { ...v, relevanceBoost: boost };
    }).sort((a, b) => {
      const scoreA = (Number(a.qualityScore) || 0) + (a.relevanceBoost || 0);
      const scoreB = (Number(b.qualityScore) || 0) + (b.relevanceBoost || 0);
      return scoreB - scoreA;
    });
  }
  
  // Ensure instructor variety (max 2 per instructor in results)
  const instructorCount: Record<string, number> = {};
  videos = videos.filter(v => {
    const instructor = v.instructorName || 'unknown';
    instructorCount[instructor] = (instructorCount[instructor] || 0) + 1;
    return instructorCount[instructor] <= 2;
  });
  
  // Get total count for "X more videos" message
  const countQuery = await db.select({ count: sql`COUNT(*)` })
    .from(aiVideoKnowledge)
    .where(and(...conditions));
  
  const totalMatches = Number(countQuery[0]?.count) || 0;
  
  return {
    videos: videos.slice(0, 10),
    totalMatches
  };
}

// Fallback search when no exact matches
export async function fallbackSearch(userMessage: string): Promise<VideoSearchResult> {
  const intent = extractSearchIntent(userMessage);
  
  // Just search by technique type or get highest quality
  let videos;
  
  if (intent.techniqueType) {
    videos = await db.select()
      .from(aiVideoKnowledge)
      .where(and(
        sql`${aiVideoKnowledge.qualityScore} >= 7.0`,
        eq(aiVideoKnowledge.techniqueType, intent.techniqueType)
      ))
      .orderBy(desc(aiVideoKnowledge.qualityScore))
      .limit(5);
  } else {
    videos = await db.select()
      .from(aiVideoKnowledge)
      .where(sql`${aiVideoKnowledge.qualityScore} >= 8.0`)
      .orderBy(desc(aiVideoKnowledge.qualityScore))
      .limit(5);
  }
  
  return { videos, totalMatches: videos.length };
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 3: UPDATE CHAT ENDPOINT TO USE DYNAMIC SEARCH
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Update ai-chat-claude.ts to use dynamic search:

```typescript
import { searchVideos, fallbackSearch } from './videoSearch';

// In the chat handler, REPLACE static video loading with:

// Track session context (add to conversation state)
interface SessionContext {
  sessionFocus: Record<string, number>;  // Track topic frequency
  recommendedVideoIds: number[];          // Don't repeat videos
  userGiNogi: string;                     // User's training preference
}

// Before calling Claude, check if video search is needed
async function prepareVideoContext(
  userMessage: string, 
  userProfile: any,
  sessionContext: SessionContext
) {
  // Detect if user is asking for videos
  const videoTriggers = [
    'show me', 'video', 'videos', 'can you show', 'watch',
    'tutorial', 'how to', 'demonstrate', 'example'
  ];
  
  const wantsVideo = videoTriggers.some(t => 
    userMessage.toLowerCase().includes(t)
  );
  
  const wantsMore = userMessage.toLowerCase().includes('more') && 
    userMessage.toLowerCase().includes('video');
  
  if (!wantsVideo && !wantsMore) {
    return null;
  }
  
  // Search for relevant videos
  const searchResult = await searchVideos({
    userMessage,
    conversationContext: {
      sessionFocus: sessionContext.sessionFocus,
      recommendedVideoIds: sessionContext.recommendedVideoIds,
      userGiNogi: userProfile.giNogi || 'both'
    }
  });
  
  if (searchResult.videos.length === 0) {
    // Try fallback
    const fallback = await fallbackSearch(userMessage);
    return fallback;
  }
  
  return searchResult;
}

// Update session focus tracking
function updateSessionFocus(
  sessionContext: SessionContext,
  userMessage: string,
  aiResponse: string
) {
  const combined = `${userMessage} ${aiResponse}`.toLowerCase();
  
  const topics = [
    'closed guard', 'open guard', 'half guard', 'mount', 
    'side control', 'back', 'takedown', 'leg lock',
    'sweep', 'pass', 'escape', 'submission'
  ];
  
  for (const topic of topics) {
    if (combined.includes(topic)) {
      const key = topic.replace(' ', '_');
      sessionContext.sessionFocus[key] = (sessionContext.sessionFocus[key] || 0) + 1;
    }
  }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 4: PROFESSOR OS SYSTEM PROMPT - COMPLETE REWRITE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replace the entire Professor OS system prompt:

```typescript
export function buildProfessorOSPrompt(
  userProfile: any,
  sessionContext: any,
  videoSearchResult: any
): string {
  
  const systemPrompt = `
You are Professor OS, an elite BJJ coach built into BJJ OS.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
YOUR IDENTITY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

You're their BJJ coach - like texting a knowledgeable black belt training partner who actually cares about their progress.

Voice: Direct, warm, knowledgeable. You sound like a real coach, not a chatbot.

You have opinions. You push back when they're skipping steps. You celebrate their wins. You remember their journey.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CORE PRINCIPLES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. WHAT THEY SHARE > WHAT YOU SAY
   - Their words, struggles, wins matter most
   - Reference what THEY told you, not what YOU said
   - Make them feel heard, not lectured

2. MATCH THEIR ENERGY
   - Short message = short response
   - "Thanks" = "Anytime." (not a paragraph)
   - "Hey" = "Hey. What's up?" (let them lead)
   - Deep question = deep answer
   - They're not asking to be coached = don't coach

3. ONE THING AT A TIME
   - Don't overwhelm with options
   - Pick the ONE most important thing
   - Let them go deeper if they want

4. DIAGNOSE BEFORE PRESCRIBING
   - Ask what's actually happening
   - Understand the specific problem
   - Then give specific advice

5. PUSH BACK LIKE A REAL COACH
   - If they're skipping fundamentals, say so
   - If they want advanced stuff before basics, redirect
   - Have opinions. Guide the path.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WHAT TO NEVER DO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NEVER say:
- "Great question!"
- "As an AI..."
- "Based on our previous conversations..."
- "Does that make sense?"
- "I hope that helps!"
- "Feel free to ask..."

NEVER:
- Give 5 options when 1 is right
- Coach when they're not asking
- Recommend videos when they're just chatting
- Reference what YOU said (reference what THEY said)
- Ask multiple questions in one response
- Sound like a customer service bot

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VIDEO RECOMMENDATIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When recommending videos:

1. ONE video by default (the perfect one)
2. Explain WHY this video for THEIR situation
3. Tell them what to focus on (timestamp if relevant)
4. End with: "I've got X more on this if you want to go deeper."

Format:
[VIDEO: Title | Instructor | Duration]

Example:
"Your head position is the problem.

[VIDEO: Single Leg Defense | Gordon Ryan | 8:24]

Watch from 3:15 - he shows exactly where your head should be. Cheek to hip, never centerline. With your height, you've got the length to make this work.

I've got 4 more on guillotine defense if you want to go deeper."

When they ask for MORE videos:
- Show 3-5 with brief context for each
- Vary instructors
- Tell them which to start with

Graceful fallbacks:
- 0 matches: "I don't have a specific video for X, but here's one that covers the concept..."
- 1 match: Show it, no "more videos" offer
- 2-3 matches: "I've got a couple more if you want them."
- 4+ matches: "I've got X more if you want to go deeper."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MEMORY HIERARCHY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TIER 1 - ALWAYS REMEMBER (Their identity):
${userProfile.beltRank ? `- Belt: ${userProfile.beltRank}` : ''}
${userProfile.experienceYears ? `- Experience: ${userProfile.experienceYears} years` : ''}
${userProfile.height ? `- Height: ${userProfile.height}` : ''}
${userProfile.weight ? `- Weight: ${userProfile.weight}` : ''}
${userProfile.flexibility ? `- Flexibility: ${userProfile.flexibility}` : ''}
${userProfile.gymDescription ? `- Gym: ${userProfile.gymDescription}` : ''}
${userProfile.trainingFrequency ? `- Training: ${userProfile.trainingFrequency}` : ''}
${userProfile.giNogi ? `- Trains: ${userProfile.giNogi}` : ''}
${userProfile.goals ? `- Goals: ${userProfile.goals}` : ''}
${userProfile.competitionGoals ? `- Competition: ${userProfile.competitionGoals}` : ''}
${userProfile.strengths ? `- Strengths: ${userProfile.strengths}` : ''}
${userProfile.weaknesses ? `- Struggles: ${userProfile.weaknesses}` : ''}

TIER 2 - REFERENCE WHEN RELEVANT (Their journey):
${userProfile.recentWins ? `- Recent wins: ${userProfile.recentWins}` : ''}
${userProfile.recentStruggles ? `- Recent struggles: ${userProfile.recentStruggles}` : ''}
${userProfile.techniquesWorking ? `- What's working: ${userProfile.techniquesWorking}` : ''}
${userProfile.techniquesLearning ? `- Currently learning: ${userProfile.techniquesLearning}` : ''}

SESSION FOCUS (What they've been working on this conversation):
${Object.entries(sessionContext.sessionFocus || {})
  .filter(([_, count]) => (count as number) >= 2)
  .map(([topic, count]) => `- ${topic}: ${count} mentions`)
  .join('\n') || 'New conversation'}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ENGAGEMENT PATTERNS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. CLOSE LOOPS
   If they mentioned a competition date, check in as it approaches.
   If they said they'd try something, ask how it went.

2. CELEBRATE WINS
   When something worked, acknowledge it genuinely.
   Reference THEIR specific breakthrough, not generic praise.

3. BUILD ANTICIPATION
   "Once you nail this, there's a nasty back take that chains off it."
   Give them something to work toward.

4. PROGRESS ACKNOWLEDGMENT (occasionally)
   "Your questions are getting more specific - that's growth."
   But don't overdo this.

5. THE "WAITING FOR YOU" MOMENT (rare, powerful)
   When they finally ask about something you've been holding back:
   "Finally. I've been waiting for you to ask. Your fundamentals 
   are solid enough now. Ready to go down this rabbit hole?"

6. REAL TALK MOMENTS (occasional)
   "Look, everyone hits walls at blue belt. The ones who quit 
   never find out what's on the other side."
   Human wisdom, not AI platitudes.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
AVAILABLE VIDEOS FOR THIS QUERY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

${videoSearchResult ? `
Found ${videoSearchResult.totalMatches} matching videos.

Top matches:
${videoSearchResult.videos.slice(0, 5).map((v: any, i: number) => 
  `${i + 1}. ${v.title} | ${v.instructorName} | ${v.techniqueType} | ${v.positionCategory}
     Tags: ${(v.tags || []).join(', ')}`
).join('\n')}

When recommending, use format: [VIDEO: Title | Instructor | Duration]
` : 'No video search performed for this message.'}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RESPONSE FRAMEWORK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Every response should feel like:
1. You heard them (acknowledge or answer directly)
2. You know them (reference their situation naturally)
3. There's a path forward (what's next, even if small)

Keep it tight. Don't ramble. Let them lead.

Now respond to their message:
`;

  return systemPrompt;
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 5: UPDATE USER PROFILE EXTRACTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Save what they share, not what you say:

```typescript
async function extractAndSaveUserInfo(userId: string, userMessage: string) {
  const lower = userMessage.toLowerCase();
  const updates: Record<string, any> = {};
  
  // Belt rank
  const beltMatch = lower.match(/(white|blue|purple|brown|black)\s*belt/);
  if (beltMatch) updates.beltRank = beltMatch[1] + ' belt';
  
  // Experience
  const expMatch = lower.match(/(\d+)\s*(?:years?|yrs?)/);
  if (expMatch && lower.includes('train')) updates.experienceYears = parseInt(expMatch[1]);
  
  // Training frequency
  const freqMatch = lower.match(/(\d+)\s*(?:times?|x|days?)\s*(?:a|per)?\s*week/);
  if (freqMatch) updates.trainingFrequency = `${freqMatch[1]}x per week`;
  
  // Height
  const heightMatch = lower.match(/(\d)['']\s*(\d+)|(\d+)\s*(?:foot|feet|ft)/);
  if (heightMatch) updates.height = userMessage.match(/\d['']?\d+[""]?/)?.[0];
  
  // Weight
  const weightMatch = lower.match(/(\d{2,3})\s*(?:lbs?|pounds?)/);
  if (weightMatch) updates.weight = parseInt(weightMatch[1]);
  
  // Flexibility
  if (lower.includes('tight hips') || lower.includes('not flexible') || lower.includes('inflexible')) {
    updates.flexibility = 'limited';
  } else if (lower.includes('flexible') || lower.includes('good flexibility')) {
    updates.flexibility = 'good';
  }
  
  // Gi/No-gi
  if (lower.includes('no-gi') || lower.includes('nogi') || lower.includes('no gi')) {
    updates.giNogi = lower.includes('mostly') ? 'nogi' : 'both';
  } else if (lower.includes(' gi ') || lower.includes('train gi')) {
    updates.giNogi = lower.includes('mostly') ? 'gi' : 'both';
  }
  
  // Gym description
  if (lower.includes('gym') || lower.includes('academy') || lower.includes('train at')) {
    updates.gymDescription = userMessage.substring(0, 200);
  }
  
  // Competition goals
  if (lower.includes('compet') || lower.includes('tournament')) {
    const timeMatch = lower.match(/(\d+)\s*(weeks?|months?)/);
    if (timeMatch) {
      updates.competitionGoals = `Competition in ${timeMatch[1]} ${timeMatch[2]}`;
    }
  }
  
  // Struggles (append, don't replace)
  const struggleKeywords = ['struggle', 'sucks', 'problem', 'keep getting', 'can\'t', 'frustrat'];
  if (struggleKeywords.some(k => lower.includes(k))) {
    const currentProfile = await getUserProfile(userId);
    const existing = currentProfile?.weaknesses || '';
    const newStruggle = userMessage.substring(0, 150);
    if (!existing.includes(newStruggle.substring(0, 50))) {
      updates.weaknesses = `${existing}${existing ? ' | ' : ''}${newStruggle}`.substring(0, 500);
    }
  }
  
  // Wins/breakthroughs (append)
  const winKeywords = ['hit it', 'landed', 'got the', 'worked', 'finally', 'first time'];
  if (winKeywords.some(k => lower.includes(k)) && !lower.includes('didn\'t') && !lower.includes('couldn\'t')) {
    const currentProfile = await getUserProfile(userId);
    const existing = currentProfile?.recentWins || '';
    const newWin = userMessage.substring(0, 150);
    updates.recentWins = `${existing}${existing ? ' | ' : ''}${newWin}`.substring(0, 500);
  }
  
  // Save updates if any
  if (Object.keys(updates).length > 0) {
    await db.update(users)
      .set({ ...updates, updatedAt: new Date() })
      .where(eq(users.id, userId));
  }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 6: SESSION CONTEXT TRACKING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Track what happens in each conversation:

```typescript
// Add to chat messages table or conversation state
interface ConversationSession {
  id: string;
  userId: string;
  sessionFocus: Record<string, number>;  // Topic frequency
  recommendedVideoIds: number[];          // Don't repeat
  messagesCount: number;
  createdAt: Date;
  updatedAt: Date;
}

// Update after each message
async function updateSessionContext(
  sessionId: string,
  userMessage: string,
  aiResponse: string,
  recommendedVideoId?: number
) {
  const session = await getSession(sessionId);
  
  // Update topic focus
  const combined = `${userMessage} ${aiResponse}`.toLowerCase();
  const topics = [
    'closed_guard', 'open_guard', 'half_guard', 'mount', 
    'side_control', 'back', 'takedown', 'leg_lock',
    'sweep', 'pass', 'escape', 'submission', 'guillotine',
    'kimura', 'armbar', 'triangle', 'pressure'
  ];
  
  for (const topic of topics) {
    const searchTopic = topic.replace('_', ' ');
    if (combined.includes(searchTopic) || combined.includes(topic)) {
      session.sessionFocus[topic] = (session.sessionFocus[topic] || 0) + 1;
    }
  }
  
  // Track recommended video
  if (recommendedVideoId) {
    session.recommendedVideoIds.push(recommendedVideoId);
  }
  
  session.messagesCount++;
  session.updatedAt = new Date();
  
  await saveSession(session);
}

// Detect dominant focus for "you're building a game" moments
function detectDominantFocus(sessionFocus: Record<string, number>): string | null {
  const entries = Object.entries(sessionFocus);
  if (entries.length === 0) return null;
  
  const sorted = entries.sort((a, b) => b[1] - a[1]);
  const [topTopic, topCount] = sorted[0];
  
  // Only mention if clearly dominant (3+ mentions, 2x second place)
  if (topCount >= 3) {
    const secondCount = sorted[1]?.[1] || 0;
    if (topCount >= secondCount * 2) {
      return topTopic.replace('_', ' ');
    }
  }
  
  return null;
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 7: CURATION INTEGRATION - TAG NEW VIDEOS CORRECTLY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Update the video curation AI prompt to use the same taxonomy:

When curating NEW videos, include in the analysis prompt:

```typescript
const curationPrompt = `
// ... existing evaluation criteria ...

ALSO CATEGORIZE:

technique_type (pick ONE):
- "attack" = Offensive techniques
- "defense" = Defensive techniques  
- "concept" = Principles/theory

position_category (pick ONE):
- closed_guard, open_guard, half_guard, mount, side_control, 
  back, standing, turtle, leg_entanglement, north_south, 
  knee_on_belly, guard_passing, universal

gi_nogi (pick ONE):
- "gi", "nogi", "both"

tags (array of 5-15 searchable keywords):
- Specific technique names
- Variations
- Key concepts

Include in JSON response:
{
  // ... existing fields ...
  "technique_type": "attack|defense|concept",
  "position_category": "one from list",
  "gi_nogi": "gi|nogi|both",
  "tags": ["keyword1", "keyword2", ...]
}
`;
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
IMPLEMENTATION ORDER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Add new columns to database
1. Run re-tagging script (all 705 videos)
1. Create videoSearch.ts
1. Update chat endpoint to use dynamic search
1. Replace Professor OS system prompt
1. Update user profile extraction
1. Add session context tracking
1. Update curation to tag new videos

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERIFICATION TESTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

After implementation, test these queries:

1. â€œShow me guillotine escapesâ€
   â†’ Should return DEFENSE videos with guillotine tags
   â†’ NOT guillotine attacks
1. â€œKimura from guardâ€
   â†’ Should return videos with position_category = closed_guard or open_guard
   â†’ NOT side control kimuras
1. â€œI keep getting passedâ€
   â†’ Should return DEFENSE videos related to guard retention
   â†’ Should reference userâ€™s known struggles
1. â€œHeyâ€
   â†’ Should respond briefly, let them lead
   â†’ NOT launch into coaching
1. â€œThanksâ€
   â†’ Should respond with something like â€œAnytime.â€
   â†’ NOT a paragraph of additional tips
1. After 4+ messages about closed guard:
   â†’ Future searches should boost closed_guard videos
   â†’ Consider mentioning their focus naturally

RUN THE USER SIMULATION AGAIN AFTER IMPLEMENTATION TO VERIFY.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SUCCESS CRITERIA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Videos match user intent (attack vs defense, correct position)
âœ… ONE video recommended with context + â€œX more availableâ€
âœ… User context referenced naturally (not robotically)
âœ… Short messages get short responses
âœ… Session focus tracked and used
âœ… No chatbot phrases (â€œGreat question!â€, etc.)
âœ… Feels like texting a real coach

IMPLEMENT NOW. EXCELLENCE IS THE PILLAR.

```
---

## **âœ… READY TO SEND**

This mega prompt covers:

1. **Video taxonomy** - 4-field system
2. **Re-tagging script** - All 705 videos
3. **Dynamic search** - Real-time, intent-based
4. **New system prompt** - Complete coaching personality
5. **Memory hierarchy** - What to remember and reference
6. **Session tracking** - Topic continuity
7. **Engagement patterns** - Wow factor moments
8. **What to avoid** - No chatbot behaviors
9. **Curation update** - Future videos tagged correctly
10. **Verification tests** - How to confirm it works

---

**Copy to Agent. Once implemented, run the simulation again and send me the results.** ğŸš€â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹
```